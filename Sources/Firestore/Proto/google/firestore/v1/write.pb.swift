// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/firestore/v1/write.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A write on a document.
public struct Google_Firestore_V1_Write {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation to execute.
  public var operation: Google_Firestore_V1_Write.OneOf_Operation? = nil

  /// A document to write.
  public var update: Google_Firestore_V1_Document {
    get {
      if case .update(let v)? = operation {return v}
      return Google_Firestore_V1_Document()
    }
    set {operation = .update(newValue)}
  }

  /// A document name to delete. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  public var delete: String {
    get {
      if case .delete(let v)? = operation {return v}
      return String()
    }
    set {operation = .delete(newValue)}
  }

  /// Applies a transformation to a document.
  public var transform: Google_Firestore_V1_DocumentTransform {
    get {
      if case .transform(let v)? = operation {return v}
      return Google_Firestore_V1_DocumentTransform()
    }
    set {operation = .transform(newValue)}
  }

  /// The fields to update in this write.
  ///
  /// This field can be set only when the operation is `update`.
  /// If the mask is not set for an `update` and the document exists, any
  /// existing data will be overwritten.
  /// If the mask is set and the document on the server has fields not covered by
  /// the mask, they are left unchanged.
  /// Fields referenced in the mask, but not present in the input document, are
  /// deleted from the document on the server.
  /// The field paths in this mask must not contain a reserved field name.
  public var updateMask: Google_Firestore_V1_DocumentMask {
    get {return _updateMask ?? Google_Firestore_V1_DocumentMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// The transforms to perform after update.
  ///
  /// This field can be set only when the operation is `update`. If present, this
  /// write is equivalent to performing `update` and `transform` to the same
  /// document atomically and in order.
  public var updateTransforms: [Google_Firestore_V1_DocumentTransform.FieldTransform] = []

  /// An optional precondition on the document.
  ///
  /// The write will fail if this is set and not met by the target document.
  public var currentDocument: Google_Firestore_V1_Precondition {
    get {return _currentDocument ?? Google_Firestore_V1_Precondition()}
    set {_currentDocument = newValue}
  }
  /// Returns true if `currentDocument` has been explicitly set.
  public var hasCurrentDocument: Bool {return self._currentDocument != nil}
  /// Clears the value of `currentDocument`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentDocument() {self._currentDocument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The operation to execute.
  public enum OneOf_Operation: Equatable {
    /// A document to write.
    case update(Google_Firestore_V1_Document)
    /// A document name to delete. In the format:
    /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
    case delete(String)
    /// Applies a transformation to a document.
    case transform(Google_Firestore_V1_DocumentTransform)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_Write.OneOf_Operation, rhs: Google_Firestore_V1_Write.OneOf_Operation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.update, .update): return {
        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delete, .delete): return {
        guard case .delete(let l) = lhs, case .delete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transform, .transform): return {
        guard case .transform(let l) = lhs, case .transform(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _updateMask: Google_Firestore_V1_DocumentMask? = nil
  fileprivate var _currentDocument: Google_Firestore_V1_Precondition? = nil
}

/// A transformation of a document.
public struct Google_Firestore_V1_DocumentTransform {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the document to transform.
  public var document: String = String()

  /// The list of transformations to apply to the fields of the document, in
  /// order.
  /// This must not be empty.
  public var fieldTransforms: [Google_Firestore_V1_DocumentTransform.FieldTransform] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A transformation of a field of the document.
  public struct FieldTransform {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The path of the field. See
    /// [Document.fields][google.firestore.v1.Document.fields] for the field path
    /// syntax reference.
    public var fieldPath: String = String()

    /// The transformation to apply on the field.
    public var transformType: Google_Firestore_V1_DocumentTransform.FieldTransform.OneOf_TransformType? = nil

    /// Sets the field to the given server value.
    public var setToServerValue: Google_Firestore_V1_DocumentTransform.FieldTransform.ServerValue {
      get {
        if case .setToServerValue(let v)? = transformType {return v}
        return .unspecified
      }
      set {transformType = .setToServerValue(newValue)}
    }

    /// Adds the given value to the field's current value.
    ///
    /// This must be an integer or a double value.
    /// If the field is not an integer or double, or if the field does not yet
    /// exist, the transformation will set the field to the given value.
    /// If either of the given value or the current field value are doubles,
    /// both values will be interpreted as doubles. Double arithmetic and
    /// representation of double values follow IEEE 754 semantics.
    /// If there is positive/negative integer overflow, the field is resolved
    /// to the largest magnitude positive/negative integer.
    public var increment: Google_Firestore_V1_Value {
      get {
        if case .increment(let v)? = transformType {return v}
        return Google_Firestore_V1_Value()
      }
      set {transformType = .increment(newValue)}
    }

    /// Sets the field to the maximum of its current value and the given value.
    ///
    /// This must be an integer or a double value.
    /// If the field is not an integer or double, or if the field does not yet
    /// exist, the transformation will set the field to the given value.
    /// If a maximum operation is applied where the field and the input value
    /// are of mixed types (that is - one is an integer and one is a double)
    /// the field takes on the type of the larger operand. If the operands are
    /// equivalent (e.g. 3 and 3.0), the field does not change.
    /// 0, 0.0, and -0.0 are all zero. The maximum of a zero stored value and
    /// zero input value is always the stored value.
    /// The maximum of any numeric value x and NaN is NaN.
    public var maximum: Google_Firestore_V1_Value {
      get {
        if case .maximum(let v)? = transformType {return v}
        return Google_Firestore_V1_Value()
      }
      set {transformType = .maximum(newValue)}
    }

    /// Sets the field to the minimum of its current value and the given value.
    ///
    /// This must be an integer or a double value.
    /// If the field is not an integer or double, or if the field does not yet
    /// exist, the transformation will set the field to the input value.
    /// If a minimum operation is applied where the field and the input value
    /// are of mixed types (that is - one is an integer and one is a double)
    /// the field takes on the type of the smaller operand. If the operands are
    /// equivalent (e.g. 3 and 3.0), the field does not change.
    /// 0, 0.0, and -0.0 are all zero. The minimum of a zero stored value and
    /// zero input value is always the stored value.
    /// The minimum of any numeric value x and NaN is NaN.
    public var minimum: Google_Firestore_V1_Value {
      get {
        if case .minimum(let v)? = transformType {return v}
        return Google_Firestore_V1_Value()
      }
      set {transformType = .minimum(newValue)}
    }

    /// Append the given elements in order if they are not already present in
    /// the current field value.
    /// If the field is not an array, or if the field does not yet exist, it is
    /// first set to the empty array.
    ///
    /// Equivalent numbers of different types (e.g. 3L and 3.0) are
    /// considered equal when checking if a value is missing.
    /// NaN is equal to NaN, and Null is equal to Null.
    /// If the input contains multiple equivalent values, only the first will
    /// be considered.
    ///
    /// The corresponding transform_result will be the null value.
    public var appendMissingElements: Google_Firestore_V1_ArrayValue {
      get {
        if case .appendMissingElements(let v)? = transformType {return v}
        return Google_Firestore_V1_ArrayValue()
      }
      set {transformType = .appendMissingElements(newValue)}
    }

    /// Remove all of the given elements from the array in the field.
    /// If the field is not an array, or if the field does not yet exist, it is
    /// set to the empty array.
    ///
    /// Equivalent numbers of the different types (e.g. 3L and 3.0) are
    /// considered equal when deciding whether an element should be removed.
    /// NaN is equal to NaN, and Null is equal to Null.
    /// This will remove all equivalent values if there are duplicates.
    ///
    /// The corresponding transform_result will be the null value.
    public var removeAllFromArray: Google_Firestore_V1_ArrayValue {
      get {
        if case .removeAllFromArray(let v)? = transformType {return v}
        return Google_Firestore_V1_ArrayValue()
      }
      set {transformType = .removeAllFromArray(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The transformation to apply on the field.
    public enum OneOf_TransformType: Equatable {
      /// Sets the field to the given server value.
      case setToServerValue(Google_Firestore_V1_DocumentTransform.FieldTransform.ServerValue)
      /// Adds the given value to the field's current value.
      ///
      /// This must be an integer or a double value.
      /// If the field is not an integer or double, or if the field does not yet
      /// exist, the transformation will set the field to the given value.
      /// If either of the given value or the current field value are doubles,
      /// both values will be interpreted as doubles. Double arithmetic and
      /// representation of double values follow IEEE 754 semantics.
      /// If there is positive/negative integer overflow, the field is resolved
      /// to the largest magnitude positive/negative integer.
      case increment(Google_Firestore_V1_Value)
      /// Sets the field to the maximum of its current value and the given value.
      ///
      /// This must be an integer or a double value.
      /// If the field is not an integer or double, or if the field does not yet
      /// exist, the transformation will set the field to the given value.
      /// If a maximum operation is applied where the field and the input value
      /// are of mixed types (that is - one is an integer and one is a double)
      /// the field takes on the type of the larger operand. If the operands are
      /// equivalent (e.g. 3 and 3.0), the field does not change.
      /// 0, 0.0, and -0.0 are all zero. The maximum of a zero stored value and
      /// zero input value is always the stored value.
      /// The maximum of any numeric value x and NaN is NaN.
      case maximum(Google_Firestore_V1_Value)
      /// Sets the field to the minimum of its current value and the given value.
      ///
      /// This must be an integer or a double value.
      /// If the field is not an integer or double, or if the field does not yet
      /// exist, the transformation will set the field to the input value.
      /// If a minimum operation is applied where the field and the input value
      /// are of mixed types (that is - one is an integer and one is a double)
      /// the field takes on the type of the smaller operand. If the operands are
      /// equivalent (e.g. 3 and 3.0), the field does not change.
      /// 0, 0.0, and -0.0 are all zero. The minimum of a zero stored value and
      /// zero input value is always the stored value.
      /// The minimum of any numeric value x and NaN is NaN.
      case minimum(Google_Firestore_V1_Value)
      /// Append the given elements in order if they are not already present in
      /// the current field value.
      /// If the field is not an array, or if the field does not yet exist, it is
      /// first set to the empty array.
      ///
      /// Equivalent numbers of different types (e.g. 3L and 3.0) are
      /// considered equal when checking if a value is missing.
      /// NaN is equal to NaN, and Null is equal to Null.
      /// If the input contains multiple equivalent values, only the first will
      /// be considered.
      ///
      /// The corresponding transform_result will be the null value.
      case appendMissingElements(Google_Firestore_V1_ArrayValue)
      /// Remove all of the given elements from the array in the field.
      /// If the field is not an array, or if the field does not yet exist, it is
      /// set to the empty array.
      ///
      /// Equivalent numbers of the different types (e.g. 3L and 3.0) are
      /// considered equal when deciding whether an element should be removed.
      /// NaN is equal to NaN, and Null is equal to Null.
      /// This will remove all equivalent values if there are duplicates.
      ///
      /// The corresponding transform_result will be the null value.
      case removeAllFromArray(Google_Firestore_V1_ArrayValue)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1_DocumentTransform.FieldTransform.OneOf_TransformType, rhs: Google_Firestore_V1_DocumentTransform.FieldTransform.OneOf_TransformType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.setToServerValue, .setToServerValue): return {
          guard case .setToServerValue(let l) = lhs, case .setToServerValue(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.increment, .increment): return {
          guard case .increment(let l) = lhs, case .increment(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.maximum, .maximum): return {
          guard case .maximum(let l) = lhs, case .maximum(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.minimum, .minimum): return {
          guard case .minimum(let l) = lhs, case .minimum(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.appendMissingElements, .appendMissingElements): return {
          guard case .appendMissingElements(let l) = lhs, case .appendMissingElements(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.removeAllFromArray, .removeAllFromArray): return {
          guard case .removeAllFromArray(let l) = lhs, case .removeAllFromArray(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// A value that is calculated by the server.
    public enum ServerValue: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// The time at which the server processed the request, with millisecond
      /// precision. If used on multiple fields (same or different documents) in
      /// a transaction, all the fields will get the same server timestamp.
      case requestTime // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .requestTime
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .requestTime: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Firestore_V1_DocumentTransform.FieldTransform.ServerValue: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1_DocumentTransform.FieldTransform.ServerValue] = [
    .unspecified,
    .requestTime,
  ]
}

#endif  // swift(>=4.2)

/// The result of applying a write.
public struct Google_Firestore_V1_WriteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The last update time of the document after applying the write. Not set
  /// after a `delete`.
  ///
  /// If the write did not actually change the document, this will be the
  /// previous update_time.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// The results of applying each
  /// [DocumentTransform.FieldTransform][google.firestore.v1.DocumentTransform.FieldTransform],
  /// in the same order.
  public var transformResults: [Google_Firestore_V1_Value] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A [Document][google.firestore.v1.Document] has changed.
///
/// May be the result of multiple [writes][google.firestore.v1.Write], including
/// deletes, that ultimately resulted in a new value for the
/// [Document][google.firestore.v1.Document].
///
/// Multiple [DocumentChange][google.firestore.v1.DocumentChange] messages may be
/// returned for the same logical change, if multiple targets are affected.
public struct Google_Firestore_V1_DocumentChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The new state of the [Document][google.firestore.v1.Document].
  ///
  /// If `mask` is set, contains only fields that were updated or added.
  public var document: Google_Firestore_V1_Document {
    get {return _document ?? Google_Firestore_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  /// A set of target IDs of targets that match this document.
  public var targetIds: [Int32] = []

  /// A set of target IDs for targets that no longer match this document.
  public var removedTargetIds: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Google_Firestore_V1_Document? = nil
}

/// A [Document][google.firestore.v1.Document] has been deleted.
///
/// May be the result of multiple [writes][google.firestore.v1.Write], including
/// updates, the last of which deleted the
/// [Document][google.firestore.v1.Document].
///
/// Multiple [DocumentDelete][google.firestore.v1.DocumentDelete] messages may be
/// returned for the same logical delete, if multiple targets are affected.
public struct Google_Firestore_V1_DocumentDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the [Document][google.firestore.v1.Document] that was
  /// deleted.
  public var document: String = String()

  /// A set of target IDs for targets that previously matched this entity.
  public var removedTargetIds: [Int32] = []

  /// The read timestamp at which the delete was observed.
  ///
  /// Greater or equal to the `commit_time` of the delete.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A [Document][google.firestore.v1.Document] has been removed from the view of
/// the targets.
///
/// Sent if the document is no longer relevant to a target and is out of view.
/// Can be sent instead of a DocumentDelete or a DocumentChange if the server
/// can not send the new value of the document.
///
/// Multiple [DocumentRemove][google.firestore.v1.DocumentRemove] messages may be
/// returned for the same logical write or delete, if multiple targets are
/// affected.
public struct Google_Firestore_V1_DocumentRemove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the [Document][google.firestore.v1.Document] that has
  /// gone out of view.
  public var document: String = String()

  /// A set of target IDs for targets that previously matched this document.
  public var removedTargetIds: [Int32] = []

  /// The read timestamp at which the remove was observed.
  ///
  /// Greater or equal to the `commit_time` of the change/delete/remove.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A digest of all the documents that match a given target.
public struct Google_Firestore_V1_ExistenceFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The target ID to which this filter applies.
  public var targetID: Int32 = 0

  /// The total count of documents that match
  /// [target_id][google.firestore.v1.ExistenceFilter.target_id].
  ///
  /// If different from the count of documents in the client that match, the
  /// client must manually determine which documents no longer match the target.
  public var count: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Google_Firestore_V1_Write: @unchecked Sendable {}
extension Google_Firestore_V1_Write.OneOf_Operation: @unchecked Sendable {}
extension Google_Firestore_V1_DocumentTransform: @unchecked Sendable {}
extension Google_Firestore_V1_DocumentTransform.FieldTransform: @unchecked Sendable {}
extension Google_Firestore_V1_DocumentTransform.FieldTransform.OneOf_TransformType: @unchecked Sendable {}
extension Google_Firestore_V1_DocumentTransform.FieldTransform.ServerValue: @unchecked Sendable {}
extension Google_Firestore_V1_WriteResult: @unchecked Sendable {}
extension Google_Firestore_V1_DocumentChange: @unchecked Sendable {}
extension Google_Firestore_V1_DocumentDelete: @unchecked Sendable {}
extension Google_Firestore_V1_DocumentRemove: @unchecked Sendable {}
extension Google_Firestore_V1_ExistenceFilter: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.v1"

extension Google_Firestore_V1_Write: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Write"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "update"),
    2: .same(proto: "delete"),
    6: .same(proto: "transform"),
    3: .standard(proto: "update_mask"),
    7: .standard(proto: "update_transforms"),
    4: .standard(proto: "current_document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_Document?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .update(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.operation != nil {try decoder.handleConflictingOneOf()}
          self.operation = .delete(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._currentDocument) }()
      case 6: try {
        var v: Google_Firestore_V1_DocumentTransform?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .transform(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .transform(v)
        }
      }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.updateTransforms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.operation {
    case .update?: try {
      guard case .update(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    default: break
    }
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._currentDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if case .transform(let v)? = self.operation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.updateTransforms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updateTransforms, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_Write, rhs: Google_Firestore_V1_Write) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.updateTransforms != rhs.updateTransforms {return false}
    if lhs._currentDocument != rhs._currentDocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_DocumentTransform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentTransform"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .standard(proto: "field_transforms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.document) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fieldTransforms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.document.isEmpty {
      try visitor.visitSingularStringField(value: self.document, fieldNumber: 1)
    }
    if !self.fieldTransforms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fieldTransforms, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_DocumentTransform, rhs: Google_Firestore_V1_DocumentTransform) -> Bool {
    if lhs.document != rhs.document {return false}
    if lhs.fieldTransforms != rhs.fieldTransforms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_DocumentTransform.FieldTransform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_DocumentTransform.protoMessageName + ".FieldTransform"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_path"),
    2: .standard(proto: "set_to_server_value"),
    3: .same(proto: "increment"),
    4: .same(proto: "maximum"),
    5: .same(proto: "minimum"),
    6: .standard(proto: "append_missing_elements"),
    7: .standard(proto: "remove_all_from_array"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fieldPath) }()
      case 2: try {
        var v: Google_Firestore_V1_DocumentTransform.FieldTransform.ServerValue?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.transformType != nil {try decoder.handleConflictingOneOf()}
          self.transformType = .setToServerValue(v)
        }
      }()
      case 3: try {
        var v: Google_Firestore_V1_Value?
        var hadOneofValue = false
        if let current = self.transformType {
          hadOneofValue = true
          if case .increment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transformType = .increment(v)
        }
      }()
      case 4: try {
        var v: Google_Firestore_V1_Value?
        var hadOneofValue = false
        if let current = self.transformType {
          hadOneofValue = true
          if case .maximum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transformType = .maximum(v)
        }
      }()
      case 5: try {
        var v: Google_Firestore_V1_Value?
        var hadOneofValue = false
        if let current = self.transformType {
          hadOneofValue = true
          if case .minimum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transformType = .minimum(v)
        }
      }()
      case 6: try {
        var v: Google_Firestore_V1_ArrayValue?
        var hadOneofValue = false
        if let current = self.transformType {
          hadOneofValue = true
          if case .appendMissingElements(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transformType = .appendMissingElements(v)
        }
      }()
      case 7: try {
        var v: Google_Firestore_V1_ArrayValue?
        var hadOneofValue = false
        if let current = self.transformType {
          hadOneofValue = true
          if case .removeAllFromArray(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.transformType = .removeAllFromArray(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fieldPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldPath, fieldNumber: 1)
    }
    switch self.transformType {
    case .setToServerValue?: try {
      guard case .setToServerValue(let v)? = self.transformType else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .increment?: try {
      guard case .increment(let v)? = self.transformType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .maximum?: try {
      guard case .maximum(let v)? = self.transformType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .minimum?: try {
      guard case .minimum(let v)? = self.transformType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .appendMissingElements?: try {
      guard case .appendMissingElements(let v)? = self.transformType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .removeAllFromArray?: try {
      guard case .removeAllFromArray(let v)? = self.transformType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_DocumentTransform.FieldTransform, rhs: Google_Firestore_V1_DocumentTransform.FieldTransform) -> Bool {
    if lhs.fieldPath != rhs.fieldPath {return false}
    if lhs.transformType != rhs.transformType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_DocumentTransform.FieldTransform.ServerValue: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SERVER_VALUE_UNSPECIFIED"),
    1: .same(proto: "REQUEST_TIME"),
  ]
}

extension Google_Firestore_V1_WriteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_time"),
    2: .standard(proto: "transform_results"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transformResults) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transformResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transformResults, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_WriteResult, rhs: Google_Firestore_V1_WriteResult) -> Bool {
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.transformResults != rhs.transformResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_DocumentChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentChange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    5: .standard(proto: "target_ids"),
    6: .standard(proto: "removed_target_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.targetIds) }()
      case 6: try { try decoder.decodeRepeatedInt32Field(value: &self.removedTargetIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.targetIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.targetIds, fieldNumber: 5)
    }
    if !self.removedTargetIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.removedTargetIds, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_DocumentChange, rhs: Google_Firestore_V1_DocumentChange) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs.removedTargetIds != rhs.removedTargetIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_DocumentDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentDelete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    6: .standard(proto: "removed_target_ids"),
    4: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.document) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      case 6: try { try decoder.decodeRepeatedInt32Field(value: &self.removedTargetIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.document.isEmpty {
      try visitor.visitSingularStringField(value: self.document, fieldNumber: 1)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.removedTargetIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.removedTargetIds, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_DocumentDelete, rhs: Google_Firestore_V1_DocumentDelete) -> Bool {
    if lhs.document != rhs.document {return false}
    if lhs.removedTargetIds != rhs.removedTargetIds {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_DocumentRemove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentRemove"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .standard(proto: "removed_target_ids"),
    4: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.document) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.removedTargetIds) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.document.isEmpty {
      try visitor.visitSingularStringField(value: self.document, fieldNumber: 1)
    }
    if !self.removedTargetIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.removedTargetIds, fieldNumber: 2)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_DocumentRemove, rhs: Google_Firestore_V1_DocumentRemove) -> Bool {
    if lhs.document != rhs.document {return false}
    if lhs.removedTargetIds != rhs.removedTargetIds {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ExistenceFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExistenceFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetID != 0 {
      try visitor.visitSingularInt32Field(value: self.targetID, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ExistenceFilter, rhs: Google_Firestore_V1_ExistenceFilter) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
