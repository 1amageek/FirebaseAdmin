// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/firestore/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A Firestore query.
public struct Google_Firestore_V1_StructuredQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The projection to return.
  public var select: Google_Firestore_V1_StructuredQuery.Projection {
    get {return _select ?? Google_Firestore_V1_StructuredQuery.Projection()}
    set {_select = newValue}
  }
  /// Returns true if `select` has been explicitly set.
  public var hasSelect: Bool {return self._select != nil}
  /// Clears the value of `select`. Subsequent reads from it will return its default value.
  public mutating func clearSelect() {self._select = nil}

  /// The collections to query.
  public var from: [Google_Firestore_V1_StructuredQuery.CollectionSelector] = []

  /// The filter to apply.
  public var `where`: Google_Firestore_V1_StructuredQuery.Filter {
    get {return _where ?? Google_Firestore_V1_StructuredQuery.Filter()}
    set {_where = newValue}
  }
  /// Returns true if ``where`` has been explicitly set.
  public var hasWhere: Bool {return self._where != nil}
  /// Clears the value of ``where``. Subsequent reads from it will return its default value.
  public mutating func clearWhere() {self._where = nil}

  /// The order to apply to the query results.
  ///
  /// Firestore allows callers to provide a full ordering, a partial ordering, or
  /// no ordering at all. In all cases, Firestore guarantees a stable ordering
  /// through the following rules:
  ///
  ///  * The `order_by` is required to reference all fields used with an
  ///    inequality filter.
  ///  * All fields that are required to be in the `order_by` but are not already
  ///    present are appended in lexicographical ordering of the field name.
  ///  * If an order on `__name__` is not specified, it is appended by default.
  ///
  /// Fields are appended with the same sort direction as the last order
  /// specified, or 'ASCENDING' if no order was specified. For example:
  ///
  ///  * `ORDER BY a` becomes `ORDER BY a ASC, __name__ ASC`
  ///  * `ORDER BY a DESC` becomes `ORDER BY a DESC, __name__ DESC`
  ///  * `WHERE a > 1` becomes `WHERE a > 1 ORDER BY a ASC, __name__ ASC`
  ///  * `WHERE __name__ > ... AND a > 1` becomes
  ///     `WHERE __name__ > ... AND a > 1 ORDER BY a ASC, __name__ ASC`
  public var orderBy: [Google_Firestore_V1_StructuredQuery.Order] = []

  /// A potential prefix of a position in the result set to start the query at.
  ///
  /// The ordering of the result set is based on the `ORDER BY` clause of the
  /// original query.
  ///
  /// ```
  /// SELECT * FROM k WHERE a = 1 AND b > 2 ORDER BY b ASC, __name__ ASC;
  /// ```
  ///
  /// This query's results are ordered by `(b ASC, __name__ ASC)`.
  ///
  /// Cursors can reference either the full ordering or a prefix of the location,
  /// though it cannot reference more fields than what are in the provided
  /// `ORDER BY`.
  ///
  /// Continuing off the example above, attaching the following start cursors
  /// will have varying impact:
  ///
  /// - `START BEFORE (2, /k/123)`: start the query right before `a = 1 AND
  ///    b > 2 AND __name__ > /k/123`.
  /// - `START AFTER (10)`: start the query right after `a = 1 AND b > 10`.
  ///
  /// Unlike `OFFSET` which requires scanning over the first N results to skip,
  /// a start cursor allows the query to begin at a logical position. This
  /// position is not required to match an actual result, it will scan forward
  /// from this position to find the next document.
  ///
  /// Requires:
  ///
  /// * The number of values cannot be greater than the number of fields
  ///   specified in the `ORDER BY` clause.
  public var startAt: Google_Firestore_V1_Cursor {
    get {return _startAt ?? Google_Firestore_V1_Cursor()}
    set {_startAt = newValue}
  }
  /// Returns true if `startAt` has been explicitly set.
  public var hasStartAt: Bool {return self._startAt != nil}
  /// Clears the value of `startAt`. Subsequent reads from it will return its default value.
  public mutating func clearStartAt() {self._startAt = nil}

  /// A potential prefix of a position in the result set to end the query at.
  ///
  /// This is similar to `START_AT` but with it controlling the end position
  /// rather than the start position.
  ///
  /// Requires:
  ///
  /// * The number of values cannot be greater than the number of fields
  ///   specified in the `ORDER BY` clause.
  public var endAt: Google_Firestore_V1_Cursor {
    get {return _endAt ?? Google_Firestore_V1_Cursor()}
    set {_endAt = newValue}
  }
  /// Returns true if `endAt` has been explicitly set.
  public var hasEndAt: Bool {return self._endAt != nil}
  /// Clears the value of `endAt`. Subsequent reads from it will return its default value.
  public mutating func clearEndAt() {self._endAt = nil}

  /// The number of documents to skip before returning the first result.
  ///
  /// This applies after the constraints specified by the `WHERE`, `START AT`, &
  /// `END AT` but before the `LIMIT` clause.
  ///
  /// Requires:
  ///
  /// * The value must be greater than or equal to zero if specified.
  public var offset: Int32 = 0

  /// The maximum number of results to return.
  ///
  /// Applies after all other constraints.
  ///
  /// Requires:
  ///
  /// * The value must be greater than or equal to zero if specified.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A sort direction.
  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Ascending.
    case ascending // = 1

    /// Descending.
    case descending // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .ascending
      case 2: self = .descending
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .ascending: return 1
      case .descending: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A selection of a collection, such as `messages as m1`.
  public struct CollectionSelector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The collection ID.
    /// When set, selects only collections with this ID.
    public var collectionID: String = String()

    /// When false, selects only collections that are immediate children of
    /// the `parent` specified in the containing `RunQueryRequest`.
    /// When true, selects all descendant collections.
    public var allDescendants: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A filter.
  public struct Filter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of filter.
    public var filterType: Google_Firestore_V1_StructuredQuery.Filter.OneOf_FilterType? = nil

    /// A composite filter.
    public var compositeFilter: Google_Firestore_V1_StructuredQuery.CompositeFilter {
      get {
        if case .compositeFilter(let v)? = filterType {return v}
        return Google_Firestore_V1_StructuredQuery.CompositeFilter()
      }
      set {filterType = .compositeFilter(newValue)}
    }

    /// A filter on a document field.
    public var fieldFilter: Google_Firestore_V1_StructuredQuery.FieldFilter {
      get {
        if case .fieldFilter(let v)? = filterType {return v}
        return Google_Firestore_V1_StructuredQuery.FieldFilter()
      }
      set {filterType = .fieldFilter(newValue)}
    }

    /// A filter that takes exactly one argument.
    public var unaryFilter: Google_Firestore_V1_StructuredQuery.UnaryFilter {
      get {
        if case .unaryFilter(let v)? = filterType {return v}
        return Google_Firestore_V1_StructuredQuery.UnaryFilter()
      }
      set {filterType = .unaryFilter(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of filter.
    public enum OneOf_FilterType: Equatable {
      /// A composite filter.
      case compositeFilter(Google_Firestore_V1_StructuredQuery.CompositeFilter)
      /// A filter on a document field.
      case fieldFilter(Google_Firestore_V1_StructuredQuery.FieldFilter)
      /// A filter that takes exactly one argument.
      case unaryFilter(Google_Firestore_V1_StructuredQuery.UnaryFilter)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1_StructuredQuery.Filter.OneOf_FilterType, rhs: Google_Firestore_V1_StructuredQuery.Filter.OneOf_FilterType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.compositeFilter, .compositeFilter): return {
          guard case .compositeFilter(let l) = lhs, case .compositeFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.fieldFilter, .fieldFilter): return {
          guard case .fieldFilter(let l) = lhs, case .fieldFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.unaryFilter, .unaryFilter): return {
          guard case .unaryFilter(let l) = lhs, case .unaryFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// A filter that merges multiple other filters using the given operator.
  public struct CompositeFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The operator for combining multiple filters.
    public var op: Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator = .unspecified

    /// The list of filters to combine.
    ///
    /// Requires:
    ///
    /// * At least one filter is present.
    public var filters: [Google_Firestore_V1_StructuredQuery.Filter] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A composite filter operator.
    public enum Operator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// Documents are required to satisfy all of the combined filters.
      case and // = 1

      /// Documents are required to satisfy at least one of the combined filters.
      case or // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .and
        case 2: self = .or
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .and: return 1
        case .or: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// A filter on a specific field.
  public struct FieldFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The field to filter by.
    public var field: Google_Firestore_V1_StructuredQuery.FieldReference {
      get {return _field ?? Google_Firestore_V1_StructuredQuery.FieldReference()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    /// The operator to filter by.
    public var op: Google_Firestore_V1_StructuredQuery.FieldFilter.Operator = .unspecified

    /// The value to compare to.
    public var value: Google_Firestore_V1_Value {
      get {return _value ?? Google_Firestore_V1_Value()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A field filter operator.
    public enum Operator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// The given `field` is less than the given `value`.
      ///
      /// Requires:
      ///
      /// * That `field` come first in `order_by`.
      case lessThan // = 1

      /// The given `field` is less than or equal to the given `value`.
      ///
      /// Requires:
      ///
      /// * That `field` come first in `order_by`.
      case lessThanOrEqual // = 2

      /// The given `field` is greater than the given `value`.
      ///
      /// Requires:
      ///
      /// * That `field` come first in `order_by`.
      case greaterThan // = 3

      /// The given `field` is greater than or equal to the given `value`.
      ///
      /// Requires:
      ///
      /// * That `field` come first in `order_by`.
      case greaterThanOrEqual // = 4

      /// The given `field` is equal to the given `value`.
      case equal // = 5

      /// The given `field` is not equal to the given `value`.
      ///
      /// Requires:
      ///
      /// * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
      /// * That `field` comes first in the `order_by`.
      case notEqual // = 6

      /// The given `field` is an array that contains the given `value`.
      case arrayContains // = 7

      /// The given `field` is equal to at least one value in the given array.
      ///
      /// Requires:
      ///
      /// * That `value` is a non-empty `ArrayValue` with at most 10 values.
      /// * No other `IN` or `ARRAY_CONTAINS_ANY` or `NOT_IN`.
      case `in` // = 8

      /// The given `field` is an array that contains any of the values in the
      /// given array.
      ///
      /// Requires:
      ///
      /// * That `value` is a non-empty `ArrayValue` with at most 10 values.
      /// * No other `IN` or `ARRAY_CONTAINS_ANY` or `NOT_IN`.
      case arrayContainsAny // = 9

      /// The value of the `field` is not in the given array.
      ///
      /// Requires:
      ///
      /// * That `value` is a non-empty `ArrayValue` with at most 10 values.
      /// * No other `IN`, `ARRAY_CONTAINS_ANY`, `NOT_IN`, `NOT_EQUAL`,
      ///   `IS_NOT_NULL`, or `IS_NOT_NAN`.
      /// * That `field` comes first in the `order_by`.
      case notIn // = 10
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .lessThan
        case 2: self = .lessThanOrEqual
        case 3: self = .greaterThan
        case 4: self = .greaterThanOrEqual
        case 5: self = .equal
        case 6: self = .notEqual
        case 7: self = .arrayContains
        case 8: self = .in
        case 9: self = .arrayContainsAny
        case 10: self = .notIn
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .lessThan: return 1
        case .lessThanOrEqual: return 2
        case .greaterThan: return 3
        case .greaterThanOrEqual: return 4
        case .equal: return 5
        case .notEqual: return 6
        case .arrayContains: return 7
        case .in: return 8
        case .arrayContainsAny: return 9
        case .notIn: return 10
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _field: Google_Firestore_V1_StructuredQuery.FieldReference? = nil
    fileprivate var _value: Google_Firestore_V1_Value? = nil
  }

  /// A filter with a single operand.
  public struct UnaryFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The unary operator to apply.
    public var op: Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator = .unspecified

    /// The argument to the filter.
    public var operandType: Google_Firestore_V1_StructuredQuery.UnaryFilter.OneOf_OperandType? = nil

    /// The field to which to apply the operator.
    public var field: Google_Firestore_V1_StructuredQuery.FieldReference {
      get {
        if case .field(let v)? = operandType {return v}
        return Google_Firestore_V1_StructuredQuery.FieldReference()
      }
      set {operandType = .field(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The argument to the filter.
    public enum OneOf_OperandType: Equatable {
      /// The field to which to apply the operator.
      case field(Google_Firestore_V1_StructuredQuery.FieldReference)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1_StructuredQuery.UnaryFilter.OneOf_OperandType, rhs: Google_Firestore_V1_StructuredQuery.UnaryFilter.OneOf_OperandType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.field, .field): return {
          guard case .field(let l) = lhs, case .field(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    /// A unary operator.
    public enum Operator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// The given `field` is equal to `NaN`.
      case isNan // = 2

      /// The given `field` is equal to `NULL`.
      case isNull // = 3

      /// The given `field` is not equal to `NaN`.
      ///
      /// Requires:
      ///
      /// * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
      /// * That `field` comes first in the `order_by`.
      case isNotNan // = 4

      /// The given `field` is not equal to `NULL`.
      ///
      /// Requires:
      ///
      /// * A single `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
      /// * That `field` comes first in the `order_by`.
      case isNotNull // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 2: self = .isNan
        case 3: self = .isNull
        case 4: self = .isNotNan
        case 5: self = .isNotNull
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .isNan: return 2
        case .isNull: return 3
        case .isNotNan: return 4
        case .isNotNull: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// An order on a field.
  public struct Order {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The field to order by.
    public var field: Google_Firestore_V1_StructuredQuery.FieldReference {
      get {return _field ?? Google_Firestore_V1_StructuredQuery.FieldReference()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    /// The direction to order by. Defaults to `ASCENDING`.
    public var direction: Google_Firestore_V1_StructuredQuery.Direction = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _field: Google_Firestore_V1_StructuredQuery.FieldReference? = nil
  }

  /// A reference to a field in a document, ex: `stats.operations`.
  public struct FieldReference {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The relative path of the document being referenced.
    ///
    /// Requires:
    ///
    /// * Conform to [document field name][google.firestore.v1.Document.fields]
    /// limitations.
    public var fieldPath: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The projection of document's fields to return.
  public struct Projection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The fields to return.
    ///
    /// If empty, all fields are returned. To only return the name
    /// of the document, use `['__name__']`.
    public var fields: [Google_Firestore_V1_StructuredQuery.FieldReference] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _select: Google_Firestore_V1_StructuredQuery.Projection? = nil
  fileprivate var _where: Google_Firestore_V1_StructuredQuery.Filter? = nil
  fileprivate var _startAt: Google_Firestore_V1_Cursor? = nil
  fileprivate var _endAt: Google_Firestore_V1_Cursor? = nil
  fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
}

#if swift(>=4.2)

extension Google_Firestore_V1_StructuredQuery.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1_StructuredQuery.Direction] = [
    .unspecified,
    .ascending,
    .descending,
  ]
}

extension Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator] = [
    .unspecified,
    .and,
    .or,
  ]
}

extension Google_Firestore_V1_StructuredQuery.FieldFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1_StructuredQuery.FieldFilter.Operator] = [
    .unspecified,
    .lessThan,
    .lessThanOrEqual,
    .greaterThan,
    .greaterThanOrEqual,
    .equal,
    .notEqual,
    .arrayContains,
    .in,
    .arrayContainsAny,
    .notIn,
  ]
}

extension Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator] = [
    .unspecified,
    .isNan,
    .isNull,
    .isNotNan,
    .isNotNull,
  ]
}

#endif  // swift(>=4.2)

/// Firestore query for running an aggregation over a
/// [StructuredQuery][google.firestore.v1.StructuredQuery].
public struct Google_Firestore_V1_StructuredAggregationQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The base query to aggregate over.
  public var queryType: Google_Firestore_V1_StructuredAggregationQuery.OneOf_QueryType? = nil

  /// Nested structured query.
  public var structuredQuery: Google_Firestore_V1_StructuredQuery {
    get {
      if case .structuredQuery(let v)? = queryType {return v}
      return Google_Firestore_V1_StructuredQuery()
    }
    set {queryType = .structuredQuery(newValue)}
  }

  /// Optional. Series of aggregations to apply over the results of the
  /// `structured_query`.
  ///
  /// Requires:
  ///
  /// * A minimum of one and maximum of five aggregations per query.
  public var aggregations: [Google_Firestore_V1_StructuredAggregationQuery.Aggregation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The base query to aggregate over.
  public enum OneOf_QueryType: Equatable {
    /// Nested structured query.
    case structuredQuery(Google_Firestore_V1_StructuredQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.OneOf_QueryType, rhs: Google_Firestore_V1_StructuredAggregationQuery.OneOf_QueryType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.structuredQuery, .structuredQuery): return {
        guard case .structuredQuery(let l) = lhs, case .structuredQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Defines a aggregation that produces a single result.
  public struct Aggregation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of aggregation to perform, required.
    public var `operator`: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.OneOf_Operator? = nil

    /// Count aggregator.
    public var count: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count {
      get {
        if case .count(let v)? = `operator` {return v}
        return Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count()
      }
      set {`operator` = .count(newValue)}
    }

    /// Optional. Optional name of the field to store the result of the
    /// aggregation into.
    ///
    /// If not provided, Firestore will pick a default name following the format
    /// `field_<incremental_id++>`. For example:
    ///
    /// ```
    /// AGGREGATE
    ///   COUNT_UP_TO(1) AS count_up_to_1,
    ///   COUNT_UP_TO(2),
    ///   COUNT_UP_TO(3) AS count_up_to_3,
    ///   COUNT_UP_TO(4)
    /// OVER (
    ///   ...
    /// );
    /// ```
    ///
    /// becomes:
    ///
    /// ```
    /// AGGREGATE
    ///   COUNT_UP_TO(1) AS count_up_to_1,
    ///   COUNT_UP_TO(2) AS field_1,
    ///   COUNT_UP_TO(3) AS count_up_to_3,
    ///   COUNT_UP_TO(4) AS field_2
    /// OVER (
    ///   ...
    /// );
    /// ```
    ///
    /// Requires:
    ///
    /// * Must be unique across all aggregation aliases.
    /// * Conform to [document field name][google.firestore.v1.Document.fields]
    /// limitations.
    public var alias: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of aggregation to perform, required.
    public enum OneOf_Operator: Equatable {
      /// Count aggregator.
      case count(Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.OneOf_Operator, rhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.OneOf_Operator) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.count, .count): return {
          guard case .count(let l) = lhs, case .count(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    /// Count of documents that match the query.
    ///
    /// The `COUNT(*)` aggregation function operates on the entire document
    /// so it does not require a field reference.
    public struct Count {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Optional. Optional constraint on the maximum number of documents to
      /// count.
      ///
      /// This provides a way to set an upper bound on the number of documents
      /// to scan, limiting latency and cost.
      ///
      /// Unspecified is interpreted as no bound.
      ///
      /// High-Level Example:
      ///
      /// ```
      /// AGGREGATE COUNT_UP_TO(1000) OVER ( SELECT * FROM k );
      /// ```
      ///
      /// Requires:
      ///
      /// * Must be greater than zero when present.
      public var upTo: SwiftProtobuf.Google_Protobuf_Int64Value {
        get {return _upTo ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
        set {_upTo = newValue}
      }
      /// Returns true if `upTo` has been explicitly set.
      public var hasUpTo: Bool {return self._upTo != nil}
      /// Clears the value of `upTo`. Subsequent reads from it will return its default value.
      public mutating func clearUpTo() {self._upTo = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _upTo: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    }

    public init() {}
  }

  public init() {}
}

/// A position in a query result set.
public struct Google_Firestore_V1_Cursor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The values that represent a position, in the order they appear in
  /// the order by clause of a query.
  ///
  /// Can contain fewer values than specified in the order by clause.
  public var values: [Google_Firestore_V1_Value] = []

  /// If the position is just before or just after the given values, relative
  /// to the sort order defined by the query.
  public var before: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Google_Firestore_V1_StructuredQuery: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Direction: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.CollectionSelector: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Filter: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Filter.OneOf_FilterType: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.CompositeFilter: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.FieldFilter: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.FieldFilter.Operator: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.UnaryFilter: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.UnaryFilter.OneOf_OperandType: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Order: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.FieldReference: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Projection: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.OneOf_QueryType: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.OneOf_Operator: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count: @unchecked Sendable {}
extension Google_Firestore_V1_Cursor: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.v1"

extension Google_Firestore_V1_StructuredQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructuredQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "select"),
    2: .same(proto: "from"),
    3: .same(proto: "where"),
    4: .standard(proto: "order_by"),
    7: .standard(proto: "start_at"),
    8: .standard(proto: "end_at"),
    6: .same(proto: "offset"),
    5: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._select) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.from) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._where) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.orderBy) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.offset) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._startAt) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._endAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._select {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.from.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.from, fieldNumber: 2)
    }
    try { if let v = self._where {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.orderBy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.orderBy, fieldNumber: 4)
    }
    try { if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.offset != 0 {
      try visitor.visitSingularInt32Field(value: self.offset, fieldNumber: 6)
    }
    try { if let v = self._startAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._endAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery, rhs: Google_Firestore_V1_StructuredQuery) -> Bool {
    if lhs._select != rhs._select {return false}
    if lhs.from != rhs.from {return false}
    if lhs._where != rhs._where {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs._startAt != rhs._startAt {return false}
    if lhs._endAt != rhs._endAt {return false}
    if lhs.offset != rhs.offset {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_UNSPECIFIED"),
    1: .same(proto: "ASCENDING"),
    2: .same(proto: "DESCENDING"),
  ]
}

extension Google_Firestore_V1_StructuredQuery.CollectionSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".CollectionSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "collection_id"),
    3: .standard(proto: "all_descendants"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectionID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allDescendants) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionID, fieldNumber: 2)
    }
    if self.allDescendants != false {
      try visitor.visitSingularBoolField(value: self.allDescendants, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.CollectionSelector, rhs: Google_Firestore_V1_StructuredQuery.CollectionSelector) -> Bool {
    if lhs.collectionID != rhs.collectionID {return false}
    if lhs.allDescendants != rhs.allDescendants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "composite_filter"),
    2: .standard(proto: "field_filter"),
    3: .standard(proto: "unary_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_StructuredQuery.CompositeFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .compositeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .compositeFilter(v)
        }
      }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredQuery.FieldFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .fieldFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .fieldFilter(v)
        }
      }()
      case 3: try {
        var v: Google_Firestore_V1_StructuredQuery.UnaryFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .unaryFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .unaryFilter(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.filterType {
    case .compositeFilter?: try {
      guard case .compositeFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fieldFilter?: try {
      guard case .fieldFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unaryFilter?: try {
      guard case .unaryFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.Filter, rhs: Google_Firestore_V1_StructuredQuery.Filter) -> Bool {
    if lhs.filterType != rhs.filterType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.CompositeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".CompositeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 1)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.CompositeFilter, rhs: Google_Firestore_V1_StructuredQuery.CompositeFilter) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "AND"),
    2: .same(proto: "OR"),
  ]
}

extension Google_Firestore_V1_StructuredQuery.FieldFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".FieldFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "op"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 2)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.FieldFilter, rhs: Google_Firestore_V1_StructuredQuery.FieldFilter) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.op != rhs.op {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.FieldFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "LESS_THAN"),
    2: .same(proto: "LESS_THAN_OR_EQUAL"),
    3: .same(proto: "GREATER_THAN"),
    4: .same(proto: "GREATER_THAN_OR_EQUAL"),
    5: .same(proto: "EQUAL"),
    6: .same(proto: "NOT_EQUAL"),
    7: .same(proto: "ARRAY_CONTAINS"),
    8: .same(proto: "IN"),
    9: .same(proto: "ARRAY_CONTAINS_ANY"),
    10: .same(proto: "NOT_IN"),
  ]
}

extension Google_Firestore_V1_StructuredQuery.UnaryFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".UnaryFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredQuery.FieldReference?
        var hadOneofValue = false
        if let current = self.operandType {
          hadOneofValue = true
          if case .field(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operandType = .field(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 1)
    }
    try { if case .field(let v)? = self.operandType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.UnaryFilter, rhs: Google_Firestore_V1_StructuredQuery.UnaryFilter) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.operandType != rhs.operandType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    2: .same(proto: "IS_NAN"),
    3: .same(proto: "IS_NULL"),
    4: .same(proto: "IS_NOT_NAN"),
    5: .same(proto: "IS_NOT_NULL"),
  ]
}

extension Google_Firestore_V1_StructuredQuery.Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".Order"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.Order, rhs: Google_Firestore_V1_StructuredQuery.Order) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.FieldReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".FieldReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "field_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.fieldPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.FieldReference, rhs: Google_Firestore_V1_StructuredQuery.FieldReference) -> Bool {
    if lhs.fieldPath != rhs.fieldPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.Projection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".Projection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.Projection, rhs: Google_Firestore_V1_StructuredQuery.Projection) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredAggregationQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructuredAggregationQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "structured_query"),
    3: .same(proto: "aggregations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_StructuredQuery?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .structuredQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .structuredQuery(v)
        }
      }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.aggregations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .structuredQuery(let v)? = self.queryType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.aggregations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery, rhs: Google_Firestore_V1_StructuredAggregationQuery) -> Bool {
    if lhs.queryType != rhs.queryType {return false}
    if lhs.aggregations != rhs.aggregations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredAggregationQuery.protoMessageName + ".Aggregation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    7: .same(proto: "alias"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count?
        var hadOneofValue = false
        if let current = self.`operator` {
          hadOneofValue = true
          if case .count(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`operator` = .count(v)
        }
      }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .count(let v)? = self.`operator` {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation, rhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation) -> Bool {
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.alias != rhs.alias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredAggregationQuery.Aggregation.protoMessageName + ".Count"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "up_to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._upTo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._upTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count, rhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count) -> Bool {
    if lhs._upTo != rhs._upTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "before"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.before) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    if self.before != false {
      try visitor.visitSingularBoolField(value: self.before, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_Cursor, rhs: Google_Firestore_V1_Cursor) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.before != rhs.before {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
