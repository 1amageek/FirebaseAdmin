// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/firestore/v1/firestore.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The request for
/// [Firestore.GetDocument][google.firestore.v1.Firestore.GetDocument].
public struct Google_Firestore_V1_GetDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Document to get. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  public var name: String = String()

  /// The fields to return. If not set, returns all fields.
  ///
  /// If the document has a field that is not present in this mask, that field
  /// will not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: Google_Firestore_V1_GetDocumentRequest.OneOf_ConsistencySelector? = nil

  /// Reads the document in a transaction.
  public var transaction: Data {
    get {
      if case .transaction(let v)? = consistencySelector {return v}
      return Data()
    }
    set {consistencySelector = .transaction(newValue)}
  }

  /// Reads the version of the document at the given time.
  /// This may not be older than 270 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencySelector = .readTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Reads the document in a transaction.
    case transaction(Data)
    /// Reads the version of the document at the given time.
    /// This may not be older than 270 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_GetDocumentRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_GetDocumentRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
}

/// The request for
/// [Firestore.ListDocuments][google.firestore.v1.Firestore.ListDocuments].
public struct Google_Firestore_V1_ListDocumentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource name. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents` or
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  ///
  /// For example:
  /// `projects/my-project/databases/my-database/documents` or
  /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
  public var parent: String = String()

  /// Optional. The collection ID, relative to `parent`, to list.
  ///
  /// For example: `chatrooms` or `messages`.
  ///
  /// This is optional, and when not provided, Firestore will list documents
  /// from all collections under the provided `parent`.
  public var collectionID: String = String()

  /// Optional. The maximum number of documents to return in a single response.
  ///
  /// Firestore may return fewer than this value.
  public var pageSize: Int32 = 0

  /// Optional. A page token, received from a previous `ListDocuments` response.
  ///
  /// Provide this to retrieve the subsequent page. When paginating, all other
  /// parameters (with the exception of `page_size`) must match the values set
  /// in the request that generated the page token.
  public var pageToken: String = String()

  /// Optional. The optional ordering of the documents to return.
  ///
  /// For example: `priority desc, __name__ desc`.
  ///
  /// This mirrors the [`ORDER BY`][google.firestore.v1.StructuredQuery.order_by]
  /// used in Firestore queries but in a string representation. When absent,
  /// documents are ordered based on `__name__ ASC`.
  public var orderBy: String = String()

  /// Optional. The fields to return. If not set, returns all fields.
  ///
  /// If a document has a field that is not present in this mask, that field
  /// will not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: Google_Firestore_V1_ListDocumentsRequest.OneOf_ConsistencySelector? = nil

  /// Perform the read as part of an already active transaction.
  public var transaction: Data {
    get {
      if case .transaction(let v)? = consistencySelector {return v}
      return Data()
    }
    set {consistencySelector = .transaction(newValue)}
  }

  /// Perform the read at the provided time.
  ///
  /// This may not be older than 270 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencySelector = .readTime(newValue)}
  }

  /// If the list should show missing documents.
  ///
  /// A document is missing if it does not exist, but there are sub-documents
  /// nested underneath it. When true, such missing documents will be returned
  /// with a key but will not have fields,
  /// [`create_time`][google.firestore.v1.Document.create_time], or
  /// [`update_time`][google.firestore.v1.Document.update_time] set.
  ///
  /// Requests with `show_missing` may not specify `where` or `order_by`.
  public var showMissing: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Perform the read as part of an already active transaction.
    case transaction(Data)
    /// Perform the read at the provided time.
    ///
    /// This may not be older than 270 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_ListDocumentsRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_ListDocumentsRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
}

/// The response for
/// [Firestore.ListDocuments][google.firestore.v1.Firestore.ListDocuments].
public struct Google_Firestore_V1_ListDocumentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Documents found.
  public var documents: [Google_Firestore_V1_Document] = []

  /// A token to retrieve the next page of documents.
  ///
  /// If this field is omitted, there are no subsequent pages.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for
/// [Firestore.CreateDocument][google.firestore.v1.Firestore.CreateDocument].
public struct Google_Firestore_V1_CreateDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource. For example:
  /// `projects/{project_id}/databases/{database_id}/documents` or
  /// `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`
  public var parent: String = String()

  /// Required. The collection ID, relative to `parent`, to list. For example:
  /// `chatrooms`.
  public var collectionID: String = String()

  /// The client-assigned document ID to use for this document.
  ///
  /// Optional. If not specified, an ID will be assigned by the service.
  public var documentID: String = String()

  /// Required. The document to create. `name` must not be set.
  public var document: Google_Firestore_V1_Document {
    get {return _document ?? Google_Firestore_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  /// The fields to return. If not set, returns all fields.
  ///
  /// If the document has a field that is not present in this mask, that field
  /// will not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Google_Firestore_V1_Document? = nil
  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
}

/// The request for
/// [Firestore.UpdateDocument][google.firestore.v1.Firestore.UpdateDocument].
public struct Google_Firestore_V1_UpdateDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated document.
  /// Creates the document if it does not already exist.
  public var document: Google_Firestore_V1_Document {
    get {return _document ?? Google_Firestore_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  /// The fields to update.
  /// None of the field paths in the mask may contain a reserved name.
  ///
  /// If the document exists on the server and has fields not referenced in the
  /// mask, they are left unchanged.
  /// Fields referenced in the mask, but not present in the input document, are
  /// deleted from the document on the server.
  public var updateMask: Google_Firestore_V1_DocumentMask {
    get {return _updateMask ?? Google_Firestore_V1_DocumentMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// The fields to return. If not set, returns all fields.
  ///
  /// If the document has a field that is not present in this mask, that field
  /// will not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// An optional precondition on the document.
  /// The request will fail if this is set and not met by the target document.
  public var currentDocument: Google_Firestore_V1_Precondition {
    get {return _currentDocument ?? Google_Firestore_V1_Precondition()}
    set {_currentDocument = newValue}
  }
  /// Returns true if `currentDocument` has been explicitly set.
  public var hasCurrentDocument: Bool {return self._currentDocument != nil}
  /// Clears the value of `currentDocument`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentDocument() {self._currentDocument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Google_Firestore_V1_Document? = nil
  fileprivate var _updateMask: Google_Firestore_V1_DocumentMask? = nil
  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
  fileprivate var _currentDocument: Google_Firestore_V1_Precondition? = nil
}

/// The request for
/// [Firestore.DeleteDocument][google.firestore.v1.Firestore.DeleteDocument].
public struct Google_Firestore_V1_DeleteDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Document to delete. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  public var name: String = String()

  /// An optional precondition on the document.
  /// The request will fail if this is set and not met by the target document.
  public var currentDocument: Google_Firestore_V1_Precondition {
    get {return _currentDocument ?? Google_Firestore_V1_Precondition()}
    set {_currentDocument = newValue}
  }
  /// Returns true if `currentDocument` has been explicitly set.
  public var hasCurrentDocument: Bool {return self._currentDocument != nil}
  /// Clears the value of `currentDocument`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentDocument() {self._currentDocument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _currentDocument: Google_Firestore_V1_Precondition? = nil
}

/// The request for
/// [Firestore.BatchGetDocuments][google.firestore.v1.Firestore.BatchGetDocuments].
public struct Google_Firestore_V1_BatchGetDocumentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The names of the documents to retrieve. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  /// The request will fail if any of the document is not a child resource of the
  /// given `database`. Duplicate names will be elided.
  public var documents: [String] = []

  /// The fields to return. If not set, returns all fields.
  ///
  /// If a document has a field that is not present in this mask, that field will
  /// not be returned in the response.
  public var mask: Google_Firestore_V1_DocumentMask {
    get {return _mask ?? Google_Firestore_V1_DocumentMask()}
    set {_mask = newValue}
  }
  /// Returns true if `mask` has been explicitly set.
  public var hasMask: Bool {return self._mask != nil}
  /// Clears the value of `mask`. Subsequent reads from it will return its default value.
  public mutating func clearMask() {self._mask = nil}

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: Google_Firestore_V1_BatchGetDocumentsRequest.OneOf_ConsistencySelector? = nil

  /// Reads documents in a transaction.
  public var transaction: Data {
    get {
      if case .transaction(let v)? = consistencySelector {return v}
      return Data()
    }
    set {consistencySelector = .transaction(newValue)}
  }

  /// Starts a new transaction and reads the documents.
  /// Defaults to a read-only transaction.
  /// The new transaction ID will be returned as the first response in the
  /// stream.
  public var newTransaction: Google_Firestore_V1_TransactionOptions {
    get {
      if case .newTransaction(let v)? = consistencySelector {return v}
      return Google_Firestore_V1_TransactionOptions()
    }
    set {consistencySelector = .newTransaction(newValue)}
  }

  /// Reads documents as they were at the given time.
  /// This may not be older than 270 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencySelector = .readTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Reads documents in a transaction.
    case transaction(Data)
    /// Starts a new transaction and reads the documents.
    /// Defaults to a read-only transaction.
    /// The new transaction ID will be returned as the first response in the
    /// stream.
    case newTransaction(Google_Firestore_V1_TransactionOptions)
    /// Reads documents as they were at the given time.
    /// This may not be older than 270 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_BatchGetDocumentsRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_BatchGetDocumentsRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newTransaction, .newTransaction): return {
        guard case .newTransaction(let l) = lhs, case .newTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _mask: Google_Firestore_V1_DocumentMask? = nil
}

/// The streamed response for
/// [Firestore.BatchGetDocuments][google.firestore.v1.Firestore.BatchGetDocuments].
public struct Google_Firestore_V1_BatchGetDocumentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A single result.
  /// This can be empty if the server is just returning a transaction.
  public var result: Google_Firestore_V1_BatchGetDocumentsResponse.OneOf_Result? = nil

  /// A document that was requested.
  public var found: Google_Firestore_V1_Document {
    get {
      if case .found(let v)? = result {return v}
      return Google_Firestore_V1_Document()
    }
    set {result = .found(newValue)}
  }

  /// A document name that was requested but does not exist. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  public var missing: String {
    get {
      if case .missing(let v)? = result {return v}
      return String()
    }
    set {result = .missing(newValue)}
  }

  /// The transaction that was started as part of this request.
  /// Will only be set in the first response, and only if
  /// [BatchGetDocumentsRequest.new_transaction][google.firestore.v1.BatchGetDocumentsRequest.new_transaction]
  /// was set in the request.
  public var transaction: Data = Data()

  /// The time at which the document was read.
  /// This may be monotically increasing, in this case the previous documents in
  /// the result stream are guaranteed not to have changed between their
  /// read_time and this one.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single result.
  /// This can be empty if the server is just returning a transaction.
  public enum OneOf_Result: Equatable {
    /// A document that was requested.
    case found(Google_Firestore_V1_Document)
    /// A document name that was requested but does not exist. In the format:
    /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
    case missing(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_BatchGetDocumentsResponse.OneOf_Result, rhs: Google_Firestore_V1_BatchGetDocumentsResponse.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.found, .found): return {
        guard case .found(let l) = lhs, case .found(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missing, .missing): return {
        guard case .missing(let l) = lhs, case .missing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for
/// [Firestore.BeginTransaction][google.firestore.v1.Firestore.BeginTransaction].
public struct Google_Firestore_V1_BeginTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The options for the transaction.
  /// Defaults to a read-write transaction.
  public var options: Google_Firestore_V1_TransactionOptions {
    get {return _options ?? Google_Firestore_V1_TransactionOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Google_Firestore_V1_TransactionOptions? = nil
}

/// The response for
/// [Firestore.BeginTransaction][google.firestore.v1.Firestore.BeginTransaction].
public struct Google_Firestore_V1_BeginTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction that was started.
  public var transaction: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Firestore.Commit][google.firestore.v1.Firestore.Commit].
public struct Google_Firestore_V1_CommitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The writes to apply.
  ///
  /// Always executed atomically and in order.
  public var writes: [Google_Firestore_V1_Write] = []

  /// If set, applies all writes in this transaction, and commits it.
  public var transaction: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [Firestore.Commit][google.firestore.v1.Firestore.Commit].
public struct Google_Firestore_V1_CommitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The result of applying the writes.
  ///
  /// This i-th write result corresponds to the i-th write in the
  /// request.
  public var writeResults: [Google_Firestore_V1_WriteResult] = []

  /// The time at which the commit occurred. Any read with an equal or greater
  /// `read_time` is guaranteed to see the effects of the commit.
  public var commitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _commitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_commitTime = newValue}
  }
  /// Returns true if `commitTime` has been explicitly set.
  public var hasCommitTime: Bool {return self._commitTime != nil}
  /// Clears the value of `commitTime`. Subsequent reads from it will return its default value.
  public mutating func clearCommitTime() {self._commitTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [Firestore.Rollback][google.firestore.v1.Firestore.Rollback].
public struct Google_Firestore_V1_RollbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// Required. The transaction to roll back.
  public var transaction: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery].
public struct Google_Firestore_V1_RunQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource name. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents` or
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  /// For example:
  /// `projects/my-project/databases/my-database/documents` or
  /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
  public var parent: String = String()

  /// The query to run.
  public var queryType: Google_Firestore_V1_RunQueryRequest.OneOf_QueryType? = nil

  /// A structured query.
  public var structuredQuery: Google_Firestore_V1_StructuredQuery {
    get {
      if case .structuredQuery(let v)? = queryType {return v}
      return Google_Firestore_V1_StructuredQuery()
    }
    set {queryType = .structuredQuery(newValue)}
  }

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: Google_Firestore_V1_RunQueryRequest.OneOf_ConsistencySelector? = nil

  /// Run the query within an already active transaction.
  ///
  /// The value here is the opaque transaction ID to execute the query in.
  public var transaction: Data {
    get {
      if case .transaction(let v)? = consistencySelector {return v}
      return Data()
    }
    set {consistencySelector = .transaction(newValue)}
  }

  /// Starts a new transaction and reads the documents.
  /// Defaults to a read-only transaction.
  /// The new transaction ID will be returned as the first response in the
  /// stream.
  public var newTransaction: Google_Firestore_V1_TransactionOptions {
    get {
      if case .newTransaction(let v)? = consistencySelector {return v}
      return Google_Firestore_V1_TransactionOptions()
    }
    set {consistencySelector = .newTransaction(newValue)}
  }

  /// Reads documents as they were at the given time.
  /// This may not be older than 270 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencySelector = .readTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The query to run.
  public enum OneOf_QueryType: Equatable {
    /// A structured query.
    case structuredQuery(Google_Firestore_V1_StructuredQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_RunQueryRequest.OneOf_QueryType, rhs: Google_Firestore_V1_RunQueryRequest.OneOf_QueryType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.structuredQuery, .structuredQuery): return {
        guard case .structuredQuery(let l) = lhs, case .structuredQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// The consistency mode for this transaction.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Run the query within an already active transaction.
    ///
    /// The value here is the opaque transaction ID to execute the query in.
    case transaction(Data)
    /// Starts a new transaction and reads the documents.
    /// Defaults to a read-only transaction.
    /// The new transaction ID will be returned as the first response in the
    /// stream.
    case newTransaction(Google_Firestore_V1_TransactionOptions)
    /// Reads documents as they were at the given time.
    /// This may not be older than 270 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_RunQueryRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_RunQueryRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newTransaction, .newTransaction): return {
        guard case .newTransaction(let l) = lhs, case .newTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The response for
/// [Firestore.RunQuery][google.firestore.v1.Firestore.RunQuery].
public struct Google_Firestore_V1_RunQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction that was started as part of this request.
  /// Can only be set in the first response, and only if
  /// [RunQueryRequest.new_transaction][google.firestore.v1.RunQueryRequest.new_transaction]
  /// was set in the request. If set, no other fields will be set in this
  /// response.
  public var transaction: Data = Data()

  /// A query result, not set when reporting partial progress.
  public var document: Google_Firestore_V1_Document {
    get {return _document ?? Google_Firestore_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  /// The time at which the document was read. This may be monotonically
  /// increasing; in this case, the previous documents in the result stream are
  /// guaranteed not to have changed between their `read_time` and this one.
  ///
  /// If the query returns no results, a response with `read_time` and no
  /// `document` will be sent, and this represents the time at which the query
  /// was run.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  /// The number of results that have been skipped due to an offset between
  /// the last response and the current response.
  public var skippedResults: Int32 = 0

  /// The continuation mode for the query. If present, it indicates the current
  /// query response stream has finished. This can be set with or without a
  /// `document` present, but when set, no more results are returned.
  public var continuationSelector: Google_Firestore_V1_RunQueryResponse.OneOf_ContinuationSelector? = nil

  /// If present, Firestore has completely finished the request and no more
  /// documents will be returned.
  public var done: Bool {
    get {
      if case .done(let v)? = continuationSelector {return v}
      return false
    }
    set {continuationSelector = .done(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The continuation mode for the query. If present, it indicates the current
  /// query response stream has finished. This can be set with or without a
  /// `document` present, but when set, no more results are returned.
  public enum OneOf_ContinuationSelector: Equatable {
    /// If present, Firestore has completely finished the request and no more
    /// documents will be returned.
    case done(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_RunQueryResponse.OneOf_ContinuationSelector, rhs: Google_Firestore_V1_RunQueryResponse.OneOf_ContinuationSelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.done, .done): return {
        guard case .done(let l) = lhs, case .done(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _document: Google_Firestore_V1_Document? = nil
  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for
/// [Firestore.RunAggregationQuery][google.firestore.v1.Firestore.RunAggregationQuery].
public struct Google_Firestore_V1_RunAggregationQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource name. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents` or
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  /// For example:
  /// `projects/my-project/databases/my-database/documents` or
  /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// The query to run.
  public var queryType: OneOf_QueryType? {
    get {return _storage._queryType}
    set {_uniqueStorage()._queryType = newValue}
  }

  /// An aggregation query.
  public var structuredAggregationQuery: Google_Firestore_V1_StructuredAggregationQuery {
    get {
      if case .structuredAggregationQuery(let v)? = _storage._queryType {return v}
      return Google_Firestore_V1_StructuredAggregationQuery()
    }
    set {_uniqueStorage()._queryType = .structuredAggregationQuery(newValue)}
  }

  /// The consistency mode for the query, defaults to strong consistency.
  public var consistencySelector: OneOf_ConsistencySelector? {
    get {return _storage._consistencySelector}
    set {_uniqueStorage()._consistencySelector = newValue}
  }

  /// Run the aggregation within an already active transaction.
  ///
  /// The value here is the opaque transaction ID to execute the query in.
  public var transaction: Data {
    get {
      if case .transaction(let v)? = _storage._consistencySelector {return v}
      return Data()
    }
    set {_uniqueStorage()._consistencySelector = .transaction(newValue)}
  }

  /// Starts a new transaction as part of the query, defaulting to read-only.
  ///
  /// The new transaction ID will be returned as the first response in the
  /// stream.
  public var newTransaction: Google_Firestore_V1_TransactionOptions {
    get {
      if case .newTransaction(let v)? = _storage._consistencySelector {return v}
      return Google_Firestore_V1_TransactionOptions()
    }
    set {_uniqueStorage()._consistencySelector = .newTransaction(newValue)}
  }

  /// Executes the query at the given timestamp.
  ///
  /// Requires:
  ///
  /// * Cannot be more than 270 seconds in the past.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = _storage._consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {_uniqueStorage()._consistencySelector = .readTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The query to run.
  public enum OneOf_QueryType: Equatable {
    /// An aggregation query.
    case structuredAggregationQuery(Google_Firestore_V1_StructuredAggregationQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_RunAggregationQueryRequest.OneOf_QueryType, rhs: Google_Firestore_V1_RunAggregationQueryRequest.OneOf_QueryType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.structuredAggregationQuery, .structuredAggregationQuery): return {
        guard case .structuredAggregationQuery(let l) = lhs, case .structuredAggregationQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// The consistency mode for the query, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Run the aggregation within an already active transaction.
    ///
    /// The value here is the opaque transaction ID to execute the query in.
    case transaction(Data)
    /// Starts a new transaction as part of the query, defaulting to read-only.
    ///
    /// The new transaction ID will be returned as the first response in the
    /// stream.
    case newTransaction(Google_Firestore_V1_TransactionOptions)
    /// Executes the query at the given timestamp.
    ///
    /// Requires:
    ///
    /// * Cannot be more than 270 seconds in the past.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_RunAggregationQueryRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_RunAggregationQueryRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transaction, .transaction): return {
        guard case .transaction(let l) = lhs, case .transaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newTransaction, .newTransaction): return {
        guard case .newTransaction(let l) = lhs, case .newTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The response for
/// [Firestore.RunAggregationQuery][google.firestore.v1.Firestore.RunAggregationQuery].
public struct Google_Firestore_V1_RunAggregationQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A single aggregation result.
  ///
  /// Not present when reporting partial progress.
  public var result: Google_Firestore_V1_AggregationResult {
    get {return _result ?? Google_Firestore_V1_AggregationResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {self._result = nil}

  /// The transaction that was started as part of this request.
  ///
  /// Only present on the first response when the request requested to start
  /// a new transaction.
  public var transaction: Data = Data()

  /// The time at which the aggregate value is valid for.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _result: Google_Firestore_V1_AggregationResult? = nil
  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for
/// [Firestore.PartitionQuery][google.firestore.v1.Firestore.PartitionQuery].
public struct Google_Firestore_V1_PartitionQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource name. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents`.
  /// Document resource names are not supported; only database resource names
  /// can be specified.
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// The query to partition.
  public var queryType: OneOf_QueryType? {
    get {return _storage._queryType}
    set {_uniqueStorage()._queryType = newValue}
  }

  /// A structured query.
  /// Query must specify collection with all descendants and be ordered by name
  /// ascending. Other filters, order bys, limits, offsets, and start/end
  /// cursors are not supported.
  public var structuredQuery: Google_Firestore_V1_StructuredQuery {
    get {
      if case .structuredQuery(let v)? = _storage._queryType {return v}
      return Google_Firestore_V1_StructuredQuery()
    }
    set {_uniqueStorage()._queryType = .structuredQuery(newValue)}
  }

  /// The desired maximum number of partition points.
  /// The partitions may be returned across multiple pages of results.
  /// The number must be positive. The actual number of partitions
  /// returned may be fewer.
  ///
  /// For example, this may be set to one fewer than the number of parallel
  /// queries to be run, or in running a data pipeline job, one fewer than the
  /// number of workers or compute instances available.
  public var partitionCount: Int64 {
    get {return _storage._partitionCount}
    set {_uniqueStorage()._partitionCount = newValue}
  }

  /// The `next_page_token` value returned from a previous call to
  /// PartitionQuery that may be used to get an additional set of results.
  /// There are no ordering guarantees between sets of results. Thus, using
  /// multiple sets of results will require merging the different result sets.
  ///
  /// For example, two subsequent calls using a page_token may return:
  ///
  ///  * cursor B, cursor M, cursor Q
  ///  * cursor A, cursor U, cursor W
  ///
  /// To obtain a complete result set ordered with respect to the results of the
  /// query supplied to PartitionQuery, the results sets should be merged:
  /// cursor A, cursor B, cursor M, cursor Q, cursor U, cursor W
  public var pageToken: String {
    get {return _storage._pageToken}
    set {_uniqueStorage()._pageToken = newValue}
  }

  /// The maximum number of partitions to return in this call, subject to
  /// `partition_count`.
  ///
  /// For example, if `partition_count` = 10 and `page_size` = 8, the first call
  /// to PartitionQuery will return up to 8 partitions and a `next_page_token`
  /// if more results exist. A second call to PartitionQuery will return up to
  /// 2 partitions, to complete the total of 10 specified in `partition_count`.
  public var pageSize: Int32 {
    get {return _storage._pageSize}
    set {_uniqueStorage()._pageSize = newValue}
  }

  /// The consistency mode for this request.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: OneOf_ConsistencySelector? {
    get {return _storage._consistencySelector}
    set {_uniqueStorage()._consistencySelector = newValue}
  }

  /// Reads documents as they were at the given time.
  /// This may not be older than 270 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = _storage._consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {_uniqueStorage()._consistencySelector = .readTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The query to partition.
  public enum OneOf_QueryType: Equatable {
    /// A structured query.
    /// Query must specify collection with all descendants and be ordered by name
    /// ascending. Other filters, order bys, limits, offsets, and start/end
    /// cursors are not supported.
    case structuredQuery(Google_Firestore_V1_StructuredQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_PartitionQueryRequest.OneOf_QueryType, rhs: Google_Firestore_V1_PartitionQueryRequest.OneOf_QueryType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.structuredQuery, .structuredQuery): return {
        guard case .structuredQuery(let l) = lhs, case .structuredQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// The consistency mode for this request.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Reads documents as they were at the given time.
    /// This may not be older than 270 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_PartitionQueryRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_PartitionQueryRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The response for
/// [Firestore.PartitionQuery][google.firestore.v1.Firestore.PartitionQuery].
public struct Google_Firestore_V1_PartitionQueryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partition results.
  /// Each partition is a split point that can be used by RunQuery as a starting
  /// or end point for the query results. The RunQuery requests must be made with
  /// the same query supplied to this PartitionQuery request. The partition
  /// cursors will be ordered according to same ordering as the results of the
  /// query supplied to PartitionQuery.
  ///
  /// For example, if a PartitionQuery request returns partition cursors A and B,
  /// running the following three queries will return the entire result set of
  /// the original query:
  ///
  ///  * query, end_at A
  ///  * query, start_at A, end_at B
  ///  * query, start_at B
  ///
  /// An empty result may indicate that the query has too few results to be
  /// partitioned.
  public var partitions: [Google_Firestore_V1_Cursor] = []

  /// A page token that may be used to request an additional set of results, up
  /// to the number specified by `partition_count` in the PartitionQuery request.
  /// If blank, there are no more results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [Firestore.Write][google.firestore.v1.Firestore.Write].
///
/// The first request creates a stream, or resumes an existing one from a token.
///
/// When creating a new stream, the server replies with a response containing
/// only an ID and a token, to use in the next request.
///
/// When resuming a stream, the server first streams any responses later than the
/// given token, then a response containing only an up-to-date token, to use in
/// the next request.
public struct Google_Firestore_V1_WriteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  /// This is only required in the first message.
  public var database: String = String()

  /// The ID of the write stream to resume.
  /// This may only be set in the first message. When left empty, a new write
  /// stream will be created.
  public var streamID: String = String()

  /// The writes to apply.
  ///
  /// Always executed atomically and in order.
  /// This must be empty on the first request.
  /// This may be empty on the last request.
  /// This must not be empty on all other requests.
  public var writes: [Google_Firestore_V1_Write] = []

  /// A stream token that was previously sent by the server.
  ///
  /// The client should set this field to the token from the most recent
  /// [WriteResponse][google.firestore.v1.WriteResponse] it has received. This
  /// acknowledges that the client has received responses up to this token. After
  /// sending this token, earlier tokens may not be used anymore.
  ///
  /// The server may close the stream if there are too many unacknowledged
  /// responses.
  ///
  /// Leave this field unset when creating a new stream. To resume a stream at
  /// a specific point, set this field and the `stream_id` field.
  ///
  /// Leave this field unset when creating a new stream.
  public var streamToken: Data = Data()

  /// Labels associated with this write request.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [Firestore.Write][google.firestore.v1.Firestore.Write].
public struct Google_Firestore_V1_WriteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the stream.
  /// Only set on the first message, when a new stream was created.
  public var streamID: String = String()

  /// A token that represents the position of this response in the stream.
  /// This can be used by a client to resume the stream at this point.
  ///
  /// This field is always set.
  public var streamToken: Data = Data()

  /// The result of applying the writes.
  ///
  /// This i-th write result corresponds to the i-th write in the
  /// request.
  public var writeResults: [Google_Firestore_V1_WriteResult] = []

  /// The time at which the commit occurred. Any read with an equal or greater
  /// `read_time` is guaranteed to see the effects of the write.
  public var commitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _commitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_commitTime = newValue}
  }
  /// Returns true if `commitTime` has been explicitly set.
  public var hasCommitTime: Bool {return self._commitTime != nil}
  /// Clears the value of `commitTime`. Subsequent reads from it will return its default value.
  public mutating func clearCommitTime() {self._commitTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A request for [Firestore.Listen][google.firestore.v1.Firestore.Listen]
public struct Google_Firestore_V1_ListenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The supported target changes.
  public var targetChange: Google_Firestore_V1_ListenRequest.OneOf_TargetChange? = nil

  /// A target to add to this stream.
  public var addTarget: Google_Firestore_V1_Target {
    get {
      if case .addTarget(let v)? = targetChange {return v}
      return Google_Firestore_V1_Target()
    }
    set {targetChange = .addTarget(newValue)}
  }

  /// The ID of a target to remove from this stream.
  public var removeTarget: Int32 {
    get {
      if case .removeTarget(let v)? = targetChange {return v}
      return 0
    }
    set {targetChange = .removeTarget(newValue)}
  }

  /// Labels associated with this target change.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The supported target changes.
  public enum OneOf_TargetChange: Equatable {
    /// A target to add to this stream.
    case addTarget(Google_Firestore_V1_Target)
    /// The ID of a target to remove from this stream.
    case removeTarget(Int32)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_ListenRequest.OneOf_TargetChange, rhs: Google_Firestore_V1_ListenRequest.OneOf_TargetChange) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.addTarget, .addTarget): return {
        guard case .addTarget(let l) = lhs, case .addTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.removeTarget, .removeTarget): return {
        guard case .removeTarget(let l) = lhs, case .removeTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The response for [Firestore.Listen][google.firestore.v1.Firestore.Listen].
public struct Google_Firestore_V1_ListenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The supported responses.
  public var responseType: Google_Firestore_V1_ListenResponse.OneOf_ResponseType? = nil

  /// Targets have changed.
  public var targetChange: Google_Firestore_V1_TargetChange {
    get {
      if case .targetChange(let v)? = responseType {return v}
      return Google_Firestore_V1_TargetChange()
    }
    set {responseType = .targetChange(newValue)}
  }

  /// A [Document][google.firestore.v1.Document] has changed.
  public var documentChange: Google_Firestore_V1_DocumentChange {
    get {
      if case .documentChange(let v)? = responseType {return v}
      return Google_Firestore_V1_DocumentChange()
    }
    set {responseType = .documentChange(newValue)}
  }

  /// A [Document][google.firestore.v1.Document] has been deleted.
  public var documentDelete: Google_Firestore_V1_DocumentDelete {
    get {
      if case .documentDelete(let v)? = responseType {return v}
      return Google_Firestore_V1_DocumentDelete()
    }
    set {responseType = .documentDelete(newValue)}
  }

  /// A [Document][google.firestore.v1.Document] has been removed from a target
  /// (because it is no longer relevant to that target).
  public var documentRemove: Google_Firestore_V1_DocumentRemove {
    get {
      if case .documentRemove(let v)? = responseType {return v}
      return Google_Firestore_V1_DocumentRemove()
    }
    set {responseType = .documentRemove(newValue)}
  }

  /// A filter to apply to the set of documents previously returned for the
  /// given target.
  ///
  /// Returned when documents may have been removed from the given target, but
  /// the exact documents are unknown.
  public var filter: Google_Firestore_V1_ExistenceFilter {
    get {
      if case .filter(let v)? = responseType {return v}
      return Google_Firestore_V1_ExistenceFilter()
    }
    set {responseType = .filter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The supported responses.
  public enum OneOf_ResponseType: Equatable {
    /// Targets have changed.
    case targetChange(Google_Firestore_V1_TargetChange)
    /// A [Document][google.firestore.v1.Document] has changed.
    case documentChange(Google_Firestore_V1_DocumentChange)
    /// A [Document][google.firestore.v1.Document] has been deleted.
    case documentDelete(Google_Firestore_V1_DocumentDelete)
    /// A [Document][google.firestore.v1.Document] has been removed from a target
    /// (because it is no longer relevant to that target).
    case documentRemove(Google_Firestore_V1_DocumentRemove)
    /// A filter to apply to the set of documents previously returned for the
    /// given target.
    ///
    /// Returned when documents may have been removed from the given target, but
    /// the exact documents are unknown.
    case filter(Google_Firestore_V1_ExistenceFilter)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_ListenResponse.OneOf_ResponseType, rhs: Google_Firestore_V1_ListenResponse.OneOf_ResponseType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetChange, .targetChange): return {
        guard case .targetChange(let l) = lhs, case .targetChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documentChange, .documentChange): return {
        guard case .documentChange(let l) = lhs, case .documentChange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documentDelete, .documentDelete): return {
        guard case .documentDelete(let l) = lhs, case .documentDelete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documentRemove, .documentRemove): return {
        guard case .documentRemove(let l) = lhs, case .documentRemove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filter, .filter): return {
        guard case .filter(let l) = lhs, case .filter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A specification of a set of documents to listen to.
public struct Google_Firestore_V1_Target {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of target to listen to.
  public var targetType: OneOf_TargetType? {
    get {return _storage._targetType}
    set {_uniqueStorage()._targetType = newValue}
  }

  /// A target specified by a query.
  public var query: Google_Firestore_V1_Target.QueryTarget {
    get {
      if case .query(let v)? = _storage._targetType {return v}
      return Google_Firestore_V1_Target.QueryTarget()
    }
    set {_uniqueStorage()._targetType = .query(newValue)}
  }

  /// A target specified by a set of document names.
  public var documents: Google_Firestore_V1_Target.DocumentsTarget {
    get {
      if case .documents(let v)? = _storage._targetType {return v}
      return Google_Firestore_V1_Target.DocumentsTarget()
    }
    set {_uniqueStorage()._targetType = .documents(newValue)}
  }

  /// When to start listening.
  ///
  /// If not specified, all matching Documents are returned before any
  /// subsequent changes.
  public var resumeType: OneOf_ResumeType? {
    get {return _storage._resumeType}
    set {_uniqueStorage()._resumeType = newValue}
  }

  /// A resume token from a prior
  /// [TargetChange][google.firestore.v1.TargetChange] for an identical target.
  ///
  /// Using a resume token with a different target is unsupported and may fail.
  public var resumeToken: Data {
    get {
      if case .resumeToken(let v)? = _storage._resumeType {return v}
      return Data()
    }
    set {_uniqueStorage()._resumeType = .resumeToken(newValue)}
  }

  /// Start listening after a specific `read_time`.
  ///
  /// The client must know the state of matching documents at this time.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = _storage._resumeType {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {_uniqueStorage()._resumeType = .readTime(newValue)}
  }

  /// The target ID that identifies the target on the stream. Must be a positive
  /// number and non-zero.
  public var targetID: Int32 {
    get {return _storage._targetID}
    set {_uniqueStorage()._targetID = newValue}
  }

  /// If the target should be removed once it is current and consistent.
  public var once: Bool {
    get {return _storage._once}
    set {_uniqueStorage()._once = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of target to listen to.
  public enum OneOf_TargetType: Equatable {
    /// A target specified by a query.
    case query(Google_Firestore_V1_Target.QueryTarget)
    /// A target specified by a set of document names.
    case documents(Google_Firestore_V1_Target.DocumentsTarget)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_Target.OneOf_TargetType, rhs: Google_Firestore_V1_Target.OneOf_TargetType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.query, .query): return {
        guard case .query(let l) = lhs, case .query(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.documents, .documents): return {
        guard case .documents(let l) = lhs, case .documents(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// When to start listening.
  ///
  /// If not specified, all matching Documents are returned before any
  /// subsequent changes.
  public enum OneOf_ResumeType: Equatable {
    /// A resume token from a prior
    /// [TargetChange][google.firestore.v1.TargetChange] for an identical target.
    ///
    /// Using a resume token with a different target is unsupported and may fail.
    case resumeToken(Data)
    /// Start listening after a specific `read_time`.
    ///
    /// The client must know the state of matching documents at this time.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_Target.OneOf_ResumeType, rhs: Google_Firestore_V1_Target.OneOf_ResumeType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.resumeToken, .resumeToken): return {
        guard case .resumeToken(let l) = lhs, case .resumeToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A target specified by a set of documents names.
  public struct DocumentsTarget {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The names of the documents to retrieve. In the format:
    /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
    /// The request will fail if any of the document is not a child resource of
    /// the given `database`. Duplicate names will be elided.
    public var documents: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A target specified by a query.
  public struct QueryTarget {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The parent resource name. In the format:
    /// `projects/{project_id}/databases/{database_id}/documents` or
    /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
    /// For example:
    /// `projects/my-project/databases/my-database/documents` or
    /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
    public var parent: String = String()

    /// The query to run.
    public var queryType: Google_Firestore_V1_Target.QueryTarget.OneOf_QueryType? = nil

    /// A structured query.
    public var structuredQuery: Google_Firestore_V1_StructuredQuery {
      get {
        if case .structuredQuery(let v)? = queryType {return v}
        return Google_Firestore_V1_StructuredQuery()
      }
      set {queryType = .structuredQuery(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The query to run.
    public enum OneOf_QueryType: Equatable {
      /// A structured query.
      case structuredQuery(Google_Firestore_V1_StructuredQuery)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1_Target.QueryTarget.OneOf_QueryType, rhs: Google_Firestore_V1_Target.QueryTarget.OneOf_QueryType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.structuredQuery, .structuredQuery): return {
          guard case .structuredQuery(let l) = lhs, case .structuredQuery(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Targets being watched have changed.
public struct Google_Firestore_V1_TargetChange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of change that occurred.
  public var targetChangeType: Google_Firestore_V1_TargetChange.TargetChangeType = .noChange

  /// The target IDs of targets that have changed.
  ///
  /// If empty, the change applies to all targets.
  ///
  /// The order of the target IDs is not defined.
  public var targetIds: [Int32] = []

  /// The error that resulted in this change, if applicable.
  public var cause: Google_Rpc_Status {
    get {return _cause ?? Google_Rpc_Status()}
    set {_cause = newValue}
  }
  /// Returns true if `cause` has been explicitly set.
  public var hasCause: Bool {return self._cause != nil}
  /// Clears the value of `cause`. Subsequent reads from it will return its default value.
  public mutating func clearCause() {self._cause = nil}

  /// A token that can be used to resume the stream for the given `target_ids`,
  /// or all targets if `target_ids` is empty.
  ///
  /// Not set on every target change.
  public var resumeToken: Data = Data()

  /// The consistent `read_time` for the given `target_ids` (omitted when the
  /// target_ids are not at a consistent snapshot).
  ///
  /// The stream is guaranteed to send a `read_time` with `target_ids` empty
  /// whenever the entire stream reaches a new consistent snapshot. ADD,
  /// CURRENT, and RESET messages are guaranteed to (eventually) result in a
  /// new consistent snapshot (while NO_CHANGE and REMOVE messages are not).
  ///
  /// For a given stream, `read_time` is guaranteed to be monotonically
  /// increasing.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of change.
  public enum TargetChangeType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No change has occurred. Used only to send an updated `resume_token`.
    case noChange // = 0

    /// The targets have been added.
    case add // = 1

    /// The targets have been removed.
    case remove // = 2

    /// The targets reflect all changes committed before the targets were added
    /// to the stream.
    ///
    /// This will be sent after or with a `read_time` that is greater than or
    /// equal to the time at which the targets were added.
    ///
    /// Listeners can wait for this change if read-after-write semantics
    /// are desired.
    case current // = 3

    /// The targets have been reset, and a new initial state for the targets
    /// will be returned in subsequent changes.
    ///
    /// After the initial state is complete, `CURRENT` will be returned even
    /// if the target was previously indicated to be `CURRENT`.
    case reset // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .noChange
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noChange
      case 1: self = .add
      case 2: self = .remove
      case 3: self = .current
      case 4: self = .reset
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .noChange: return 0
      case .add: return 1
      case .remove: return 2
      case .current: return 3
      case .reset: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _cause: Google_Rpc_Status? = nil
  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Firestore_V1_TargetChange.TargetChangeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_V1_TargetChange.TargetChangeType] = [
    .noChange,
    .add,
    .remove,
    .current,
    .reset,
  ]
}

#endif  // swift(>=4.2)

/// The request for
/// [Firestore.ListCollectionIds][google.firestore.v1.Firestore.ListCollectionIds].
public struct Google_Firestore_V1_ListCollectionIdsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent document. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  /// For example:
  /// `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
  public var parent: String = String()

  /// The maximum number of results to return.
  public var pageSize: Int32 = 0

  /// A page token. Must be a value from
  /// [ListCollectionIdsResponse][google.firestore.v1.ListCollectionIdsResponse].
  public var pageToken: String = String()

  /// The consistency mode for this request.
  /// If not set, defaults to strong consistency.
  public var consistencySelector: Google_Firestore_V1_ListCollectionIdsRequest.OneOf_ConsistencySelector? = nil

  /// Reads documents as they were at the given time.
  /// This may not be older than 270 seconds.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .readTime(let v)? = consistencySelector {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {consistencySelector = .readTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The consistency mode for this request.
  /// If not set, defaults to strong consistency.
  public enum OneOf_ConsistencySelector: Equatable {
    /// Reads documents as they were at the given time.
    /// This may not be older than 270 seconds.
    case readTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_ListCollectionIdsRequest.OneOf_ConsistencySelector, rhs: Google_Firestore_V1_ListCollectionIdsRequest.OneOf_ConsistencySelector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.readTime, .readTime): return {
        guard case .readTime(let l) = lhs, case .readTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// The response from
/// [Firestore.ListCollectionIds][google.firestore.v1.Firestore.ListCollectionIds].
public struct Google_Firestore_V1_ListCollectionIdsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The collection ids.
  public var collectionIds: [String] = []

  /// A page token that may be used to continue the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for
/// [Firestore.BatchWrite][google.firestore.v1.Firestore.BatchWrite].
public struct Google_Firestore_V1_BatchWriteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database name. In the format:
  /// `projects/{project_id}/databases/{database_id}`.
  public var database: String = String()

  /// The writes to apply.
  ///
  /// Method does not apply writes atomically and does not guarantee ordering.
  /// Each write succeeds or fails independently. You cannot write to the same
  /// document more than once per request.
  public var writes: [Google_Firestore_V1_Write] = []

  /// Labels associated with this batch write.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response from
/// [Firestore.BatchWrite][google.firestore.v1.Firestore.BatchWrite].
public struct Google_Firestore_V1_BatchWriteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The result of applying the writes.
  ///
  /// This i-th write result corresponds to the i-th write in the
  /// request.
  public var writeResults: [Google_Firestore_V1_WriteResult] = []

  /// The status of applying the writes.
  ///
  /// This i-th write status corresponds to the i-th write in the
  /// request.
  public var status: [Google_Rpc_Status] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Google_Firestore_V1_GetDocumentRequest: @unchecked Sendable {}
extension Google_Firestore_V1_GetDocumentRequest.OneOf_ConsistencySelector: @unchecked Sendable {}
extension Google_Firestore_V1_ListDocumentsRequest: @unchecked Sendable {}
extension Google_Firestore_V1_ListDocumentsRequest.OneOf_ConsistencySelector: @unchecked Sendable {}
extension Google_Firestore_V1_ListDocumentsResponse: @unchecked Sendable {}
extension Google_Firestore_V1_CreateDocumentRequest: @unchecked Sendable {}
extension Google_Firestore_V1_UpdateDocumentRequest: @unchecked Sendable {}
extension Google_Firestore_V1_DeleteDocumentRequest: @unchecked Sendable {}
extension Google_Firestore_V1_BatchGetDocumentsRequest: @unchecked Sendable {}
extension Google_Firestore_V1_BatchGetDocumentsRequest.OneOf_ConsistencySelector: @unchecked Sendable {}
extension Google_Firestore_V1_BatchGetDocumentsResponse: @unchecked Sendable {}
extension Google_Firestore_V1_BatchGetDocumentsResponse.OneOf_Result: @unchecked Sendable {}
extension Google_Firestore_V1_BeginTransactionRequest: @unchecked Sendable {}
extension Google_Firestore_V1_BeginTransactionResponse: @unchecked Sendable {}
extension Google_Firestore_V1_CommitRequest: @unchecked Sendable {}
extension Google_Firestore_V1_CommitResponse: @unchecked Sendable {}
extension Google_Firestore_V1_RollbackRequest: @unchecked Sendable {}
extension Google_Firestore_V1_RunQueryRequest: @unchecked Sendable {}
extension Google_Firestore_V1_RunQueryRequest.OneOf_QueryType: @unchecked Sendable {}
extension Google_Firestore_V1_RunQueryRequest.OneOf_ConsistencySelector: @unchecked Sendable {}
extension Google_Firestore_V1_RunQueryResponse: @unchecked Sendable {}
extension Google_Firestore_V1_RunQueryResponse.OneOf_ContinuationSelector: @unchecked Sendable {}
extension Google_Firestore_V1_RunAggregationQueryRequest: @unchecked Sendable {}
extension Google_Firestore_V1_RunAggregationQueryRequest.OneOf_QueryType: @unchecked Sendable {}
extension Google_Firestore_V1_RunAggregationQueryRequest.OneOf_ConsistencySelector: @unchecked Sendable {}
extension Google_Firestore_V1_RunAggregationQueryResponse: @unchecked Sendable {}
extension Google_Firestore_V1_PartitionQueryRequest: @unchecked Sendable {}
extension Google_Firestore_V1_PartitionQueryRequest.OneOf_QueryType: @unchecked Sendable {}
extension Google_Firestore_V1_PartitionQueryRequest.OneOf_ConsistencySelector: @unchecked Sendable {}
extension Google_Firestore_V1_PartitionQueryResponse: @unchecked Sendable {}
extension Google_Firestore_V1_WriteRequest: @unchecked Sendable {}
extension Google_Firestore_V1_WriteResponse: @unchecked Sendable {}
extension Google_Firestore_V1_ListenRequest: @unchecked Sendable {}
extension Google_Firestore_V1_ListenRequest.OneOf_TargetChange: @unchecked Sendable {}
extension Google_Firestore_V1_ListenResponse: @unchecked Sendable {}
extension Google_Firestore_V1_ListenResponse.OneOf_ResponseType: @unchecked Sendable {}
extension Google_Firestore_V1_Target: @unchecked Sendable {}
extension Google_Firestore_V1_Target.OneOf_TargetType: @unchecked Sendable {}
extension Google_Firestore_V1_Target.OneOf_ResumeType: @unchecked Sendable {}
extension Google_Firestore_V1_Target.DocumentsTarget: @unchecked Sendable {}
extension Google_Firestore_V1_Target.QueryTarget: @unchecked Sendable {}
extension Google_Firestore_V1_Target.QueryTarget.OneOf_QueryType: @unchecked Sendable {}
extension Google_Firestore_V1_TargetChange: @unchecked Sendable {}
extension Google_Firestore_V1_TargetChange.TargetChangeType: @unchecked Sendable {}
extension Google_Firestore_V1_ListCollectionIdsRequest: @unchecked Sendable {}
extension Google_Firestore_V1_ListCollectionIdsRequest.OneOf_ConsistencySelector: @unchecked Sendable {}
extension Google_Firestore_V1_ListCollectionIdsResponse: @unchecked Sendable {}
extension Google_Firestore_V1_BatchWriteRequest: @unchecked Sendable {}
extension Google_Firestore_V1_BatchWriteResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.v1"

extension Google_Firestore_V1_GetDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "mask"),
    3: .same(proto: "transaction"),
    5: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.consistencySelector != nil {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .transaction(v)
        }
      }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .readTime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.consistencySelector {
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .readTime?: try {
      guard case .readTime(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_GetDocumentRequest, rhs: Google_Firestore_V1_GetDocumentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs.consistencySelector != rhs.consistencySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListDocumentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDocumentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "collection_id"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    6: .standard(proto: "order_by"),
    7: .same(proto: "mask"),
    8: .same(proto: "transaction"),
    10: .standard(proto: "read_time"),
    12: .standard(proto: "show_missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectionID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      case 8: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.consistencySelector != nil {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .transaction(v)
        }
      }()
      case 10: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .readTime(v)
        }
      }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.showMissing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.collectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionID, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 6)
    }
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    switch self.consistencySelector {
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }()
    case .readTime?: try {
      guard case .readTime(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    if self.showMissing != false {
      try visitor.visitSingularBoolField(value: self.showMissing, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListDocumentsRequest, rhs: Google_Firestore_V1_ListDocumentsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.collectionID != rhs.collectionID {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs.consistencySelector != rhs.consistencySelector {return false}
    if lhs.showMissing != rhs.showMissing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListDocumentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDocumentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "documents"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.documents) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.documents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.documents, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListDocumentsResponse, rhs: Google_Firestore_V1_ListDocumentsResponse) -> Bool {
    if lhs.documents != rhs.documents {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_CreateDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "collection_id"),
    3: .standard(proto: "document_id"),
    4: .same(proto: "document"),
    5: .same(proto: "mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.documentID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.collectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionID, fieldNumber: 2)
    }
    if !self.documentID.isEmpty {
      try visitor.visitSingularStringField(value: self.documentID, fieldNumber: 3)
    }
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_CreateDocumentRequest, rhs: Google_Firestore_V1_CreateDocumentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.collectionID != rhs.collectionID {return false}
    if lhs.documentID != rhs.documentID {return false}
    if lhs._document != rhs._document {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_UpdateDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .standard(proto: "update_mask"),
    3: .same(proto: "mask"),
    4: .standard(proto: "current_document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._currentDocument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._currentDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_UpdateDocumentRequest, rhs: Google_Firestore_V1_UpdateDocumentRequest) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs._currentDocument != rhs._currentDocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_DeleteDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "current_document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._currentDocument) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._currentDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_DeleteDocumentRequest, rhs: Google_Firestore_V1_DeleteDocumentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._currentDocument != rhs._currentDocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BatchGetDocumentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchGetDocumentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "documents"),
    3: .same(proto: "mask"),
    4: .same(proto: "transaction"),
    5: .standard(proto: "new_transaction"),
    7: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.documents) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mask) }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.consistencySelector != nil {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .transaction(v)
        }
      }()
      case 5: try {
        var v: Google_Firestore_V1_TransactionOptions?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .newTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .newTransaction(v)
        }
      }()
      case 7: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .readTime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.documents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.documents, fieldNumber: 2)
    }
    try { if let v = self._mask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    switch self.consistencySelector {
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .newTransaction?: try {
      guard case .newTransaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .readTime?: try {
      guard case .readTime(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BatchGetDocumentsRequest, rhs: Google_Firestore_V1_BatchGetDocumentsRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.documents != rhs.documents {return false}
    if lhs._mask != rhs._mask {return false}
    if lhs.consistencySelector != rhs.consistencySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BatchGetDocumentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchGetDocumentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "found"),
    2: .same(proto: "missing"),
    3: .same(proto: "transaction"),
    4: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_Document?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .found(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .found(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .missing(v)
        }
      }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .found?: try {
      guard case .found(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .missing?: try {
      guard case .missing(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 3)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BatchGetDocumentsResponse, rhs: Google_Firestore_V1_BatchGetDocumentsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BeginTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BeginTransactionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BeginTransactionRequest, rhs: Google_Firestore_V1_BeginTransactionRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BeginTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BeginTransactionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BeginTransactionResponse, rhs: Google_Firestore_V1_BeginTransactionResponse) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_CommitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "writes"),
    3: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.writes) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.writes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writes, fieldNumber: 2)
    }
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_CommitRequest, rhs: Google_Firestore_V1_CommitRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.writes != rhs.writes {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_CommitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "write_results"),
    2: .standard(proto: "commit_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.writeResults) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._commitTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.writeResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writeResults, fieldNumber: 1)
    }
    try { if let v = self._commitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_CommitResponse, rhs: Google_Firestore_V1_CommitResponse) -> Bool {
    if lhs.writeResults != rhs.writeResults {return false}
    if lhs._commitTime != rhs._commitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_RollbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_RollbackRequest, rhs: Google_Firestore_V1_RollbackRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_RunQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "structured_query"),
    5: .same(proto: "transaction"),
    6: .standard(proto: "new_transaction"),
    7: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredQuery?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .structuredQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .structuredQuery(v)
        }
      }()
      case 5: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.consistencySelector != nil {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .transaction(v)
        }
      }()
      case 6: try {
        var v: Google_Firestore_V1_TransactionOptions?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .newTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .newTransaction(v)
        }
      }()
      case 7: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .readTime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if case .structuredQuery(let v)? = self.queryType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.consistencySelector {
    case .transaction?: try {
      guard case .transaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case .newTransaction?: try {
      guard case .newTransaction(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .readTime?: try {
      guard case .readTime(let v)? = self.consistencySelector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_RunQueryRequest, rhs: Google_Firestore_V1_RunQueryRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.queryType != rhs.queryType {return false}
    if lhs.consistencySelector != rhs.consistencySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_RunQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "transaction"),
    1: .same(proto: "document"),
    3: .standard(proto: "read_time"),
    4: .standard(proto: "skipped_results"),
    6: .same(proto: "done"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.skippedResults) }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.continuationSelector != nil {try decoder.handleConflictingOneOf()}
          self.continuationSelector = .done(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 2)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.skippedResults != 0 {
      try visitor.visitSingularInt32Field(value: self.skippedResults, fieldNumber: 4)
    }
    try { if case .done(let v)? = self.continuationSelector {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_RunQueryResponse, rhs: Google_Firestore_V1_RunQueryResponse) -> Bool {
    if lhs.transaction != rhs.transaction {return false}
    if lhs._document != rhs._document {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.skippedResults != rhs.skippedResults {return false}
    if lhs.continuationSelector != rhs.continuationSelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_RunAggregationQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunAggregationQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "structured_aggregation_query"),
    4: .same(proto: "transaction"),
    5: .standard(proto: "new_transaction"),
    6: .standard(proto: "read_time"),
  ]

  fileprivate class _StorageClass {
    var _parent: String = String()
    var _queryType: Google_Firestore_V1_RunAggregationQueryRequest.OneOf_QueryType?
    var _consistencySelector: Google_Firestore_V1_RunAggregationQueryRequest.OneOf_ConsistencySelector?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parent = source._parent
      _queryType = source._queryType
      _consistencySelector = source._consistencySelector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 2: try {
          var v: Google_Firestore_V1_StructuredAggregationQuery?
          var hadOneofValue = false
          if let current = _storage._queryType {
            hadOneofValue = true
            if case .structuredAggregationQuery(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._queryType = .structuredAggregationQuery(v)
          }
        }()
        case 4: try {
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {
            if _storage._consistencySelector != nil {try decoder.handleConflictingOneOf()}
            _storage._consistencySelector = .transaction(v)
          }
        }()
        case 5: try {
          var v: Google_Firestore_V1_TransactionOptions?
          var hadOneofValue = false
          if let current = _storage._consistencySelector {
            hadOneofValue = true
            if case .newTransaction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._consistencySelector = .newTransaction(v)
          }
        }()
        case 6: try {
          var v: SwiftProtobuf.Google_Protobuf_Timestamp?
          var hadOneofValue = false
          if let current = _storage._consistencySelector {
            hadOneofValue = true
            if case .readTime(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._consistencySelector = .readTime(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
      }
      try { if case .structuredAggregationQuery(let v)? = _storage._queryType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      switch _storage._consistencySelector {
      case .transaction?: try {
        guard case .transaction(let v)? = _storage._consistencySelector else { preconditionFailure() }
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      }()
      case .newTransaction?: try {
        guard case .newTransaction(let v)? = _storage._consistencySelector else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .readTime?: try {
        guard case .readTime(let v)? = _storage._consistencySelector else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_RunAggregationQueryRequest, rhs: Google_Firestore_V1_RunAggregationQueryRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._queryType != rhs_storage._queryType {return false}
        if _storage._consistencySelector != rhs_storage._consistencySelector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_RunAggregationQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunAggregationQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "transaction"),
    3: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 2)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_RunAggregationQueryResponse, rhs: Google_Firestore_V1_RunAggregationQueryResponse) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_PartitionQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "structured_query"),
    3: .standard(proto: "partition_count"),
    4: .standard(proto: "page_token"),
    5: .standard(proto: "page_size"),
    6: .standard(proto: "read_time"),
  ]

  fileprivate class _StorageClass {
    var _parent: String = String()
    var _queryType: Google_Firestore_V1_PartitionQueryRequest.OneOf_QueryType?
    var _partitionCount: Int64 = 0
    var _pageToken: String = String()
    var _pageSize: Int32 = 0
    var _consistencySelector: Google_Firestore_V1_PartitionQueryRequest.OneOf_ConsistencySelector?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parent = source._parent
      _queryType = source._queryType
      _partitionCount = source._partitionCount
      _pageToken = source._pageToken
      _pageSize = source._pageSize
      _consistencySelector = source._consistencySelector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 2: try {
          var v: Google_Firestore_V1_StructuredQuery?
          var hadOneofValue = false
          if let current = _storage._queryType {
            hadOneofValue = true
            if case .structuredQuery(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._queryType = .structuredQuery(v)
          }
        }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._partitionCount) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._pageToken) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._pageSize) }()
        case 6: try {
          var v: SwiftProtobuf.Google_Protobuf_Timestamp?
          var hadOneofValue = false
          if let current = _storage._consistencySelector {
            hadOneofValue = true
            if case .readTime(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._consistencySelector = .readTime(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
      }
      try { if case .structuredQuery(let v)? = _storage._queryType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._partitionCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._partitionCount, fieldNumber: 3)
      }
      if !_storage._pageToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pageToken, fieldNumber: 4)
      }
      if _storage._pageSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._pageSize, fieldNumber: 5)
      }
      try { if case .readTime(let v)? = _storage._consistencySelector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_PartitionQueryRequest, rhs: Google_Firestore_V1_PartitionQueryRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._queryType != rhs_storage._queryType {return false}
        if _storage._partitionCount != rhs_storage._partitionCount {return false}
        if _storage._pageToken != rhs_storage._pageToken {return false}
        if _storage._pageSize != rhs_storage._pageSize {return false}
        if _storage._consistencySelector != rhs_storage._consistencySelector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_PartitionQueryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionQueryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partitions"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.partitions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partitions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.partitions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_PartitionQueryResponse, rhs: Google_Firestore_V1_PartitionQueryResponse) -> Bool {
    if lhs.partitions != rhs.partitions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_WriteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .standard(proto: "stream_id"),
    3: .same(proto: "writes"),
    4: .standard(proto: "stream_token"),
    5: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.writes) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.streamToken) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 2)
    }
    if !self.writes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writes, fieldNumber: 3)
    }
    if !self.streamToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamToken, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_WriteRequest, rhs: Google_Firestore_V1_WriteRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.streamID != rhs.streamID {return false}
    if lhs.writes != rhs.writes {return false}
    if lhs.streamToken != rhs.streamToken {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_WriteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WriteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .standard(proto: "stream_token"),
    3: .standard(proto: "write_results"),
    4: .standard(proto: "commit_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.streamToken) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.writeResults) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._commitTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if !self.streamToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamToken, fieldNumber: 2)
    }
    if !self.writeResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writeResults, fieldNumber: 3)
    }
    try { if let v = self._commitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_WriteResponse, rhs: Google_Firestore_V1_WriteResponse) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.streamToken != rhs.streamToken {return false}
    if lhs.writeResults != rhs.writeResults {return false}
    if lhs._commitTime != rhs._commitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListenRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .standard(proto: "add_target"),
    3: .standard(proto: "remove_target"),
    4: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try {
        var v: Google_Firestore_V1_Target?
        var hadOneofValue = false
        if let current = self.targetChange {
          hadOneofValue = true
          if case .addTarget(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.targetChange = .addTarget(v)
        }
      }()
      case 3: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.targetChange != nil {try decoder.handleConflictingOneOf()}
          self.targetChange = .removeTarget(v)
        }
      }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    switch self.targetChange {
    case .addTarget?: try {
      guard case .addTarget(let v)? = self.targetChange else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .removeTarget?: try {
      guard case .removeTarget(let v)? = self.targetChange else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListenRequest, rhs: Google_Firestore_V1_ListenRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.targetChange != rhs.targetChange {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListenResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "target_change"),
    3: .standard(proto: "document_change"),
    4: .standard(proto: "document_delete"),
    6: .standard(proto: "document_remove"),
    5: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Firestore_V1_TargetChange?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .targetChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .targetChange(v)
        }
      }()
      case 3: try {
        var v: Google_Firestore_V1_DocumentChange?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .documentChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .documentChange(v)
        }
      }()
      case 4: try {
        var v: Google_Firestore_V1_DocumentDelete?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .documentDelete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .documentDelete(v)
        }
      }()
      case 5: try {
        var v: Google_Firestore_V1_ExistenceFilter?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .filter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .filter(v)
        }
      }()
      case 6: try {
        var v: Google_Firestore_V1_DocumentRemove?
        var hadOneofValue = false
        if let current = self.responseType {
          hadOneofValue = true
          if case .documentRemove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseType = .documentRemove(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.responseType {
    case .targetChange?: try {
      guard case .targetChange(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .documentChange?: try {
      guard case .documentChange(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .documentDelete?: try {
      guard case .documentDelete(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .filter?: try {
      guard case .filter(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .documentRemove?: try {
      guard case .documentRemove(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListenResponse, rhs: Google_Firestore_V1_ListenResponse) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Target: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Target"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "query"),
    3: .same(proto: "documents"),
    4: .standard(proto: "resume_token"),
    11: .standard(proto: "read_time"),
    5: .standard(proto: "target_id"),
    6: .same(proto: "once"),
  ]

  fileprivate class _StorageClass {
    var _targetType: Google_Firestore_V1_Target.OneOf_TargetType?
    var _resumeType: Google_Firestore_V1_Target.OneOf_ResumeType?
    var _targetID: Int32 = 0
    var _once: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetType = source._targetType
      _resumeType = source._resumeType
      _targetID = source._targetID
      _once = source._once
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try {
          var v: Google_Firestore_V1_Target.QueryTarget?
          var hadOneofValue = false
          if let current = _storage._targetType {
            hadOneofValue = true
            if case .query(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._targetType = .query(v)
          }
        }()
        case 3: try {
          var v: Google_Firestore_V1_Target.DocumentsTarget?
          var hadOneofValue = false
          if let current = _storage._targetType {
            hadOneofValue = true
            if case .documents(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._targetType = .documents(v)
          }
        }()
        case 4: try {
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {
            if _storage._resumeType != nil {try decoder.handleConflictingOneOf()}
            _storage._resumeType = .resumeToken(v)
          }
        }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._targetID) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._once) }()
        case 11: try {
          var v: SwiftProtobuf.Google_Protobuf_Timestamp?
          var hadOneofValue = false
          if let current = _storage._resumeType {
            hadOneofValue = true
            if case .readTime(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._resumeType = .readTime(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._targetType {
      case .query?: try {
        guard case .query(let v)? = _storage._targetType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .documents?: try {
        guard case .documents(let v)? = _storage._targetType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      try { if case .resumeToken(let v)? = _storage._resumeType {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
      if _storage._targetID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._targetID, fieldNumber: 5)
      }
      if _storage._once != false {
        try visitor.visitSingularBoolField(value: _storage._once, fieldNumber: 6)
      }
      try { if case .readTime(let v)? = _storage._resumeType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_Target, rhs: Google_Firestore_V1_Target) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetType != rhs_storage._targetType {return false}
        if _storage._resumeType != rhs_storage._resumeType {return false}
        if _storage._targetID != rhs_storage._targetID {return false}
        if _storage._once != rhs_storage._once {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Target.DocumentsTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_Target.protoMessageName + ".DocumentsTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "documents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.documents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.documents.isEmpty {
      try visitor.visitRepeatedStringField(value: self.documents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_Target.DocumentsTarget, rhs: Google_Firestore_V1_Target.DocumentsTarget) -> Bool {
    if lhs.documents != rhs.documents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Target.QueryTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_Target.protoMessageName + ".QueryTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "structured_query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredQuery?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .structuredQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .structuredQuery(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try { if case .structuredQuery(let v)? = self.queryType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_Target.QueryTarget, rhs: Google_Firestore_V1_Target.QueryTarget) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.queryType != rhs.queryType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_TargetChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetChange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_change_type"),
    2: .standard(proto: "target_ids"),
    3: .same(proto: "cause"),
    4: .standard(proto: "resume_token"),
    6: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.targetChangeType) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.targetIds) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cause) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.resumeToken) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.targetChangeType != .noChange {
      try visitor.visitSingularEnumField(value: self.targetChangeType, fieldNumber: 1)
    }
    if !self.targetIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.targetIds, fieldNumber: 2)
    }
    try { if let v = self._cause {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.resumeToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.resumeToken, fieldNumber: 4)
    }
    try { if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_TargetChange, rhs: Google_Firestore_V1_TargetChange) -> Bool {
    if lhs.targetChangeType != rhs.targetChangeType {return false}
    if lhs.targetIds != rhs.targetIds {return false}
    if lhs._cause != rhs._cause {return false}
    if lhs.resumeToken != rhs.resumeToken {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_TargetChange.TargetChangeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_CHANGE"),
    1: .same(proto: "ADD"),
    2: .same(proto: "REMOVE"),
    3: .same(proto: "CURRENT"),
    4: .same(proto: "RESET"),
  ]
}

extension Google_Firestore_V1_ListCollectionIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollectionIdsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .standard(proto: "read_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.consistencySelector {
          hadOneofValue = true
          if case .readTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.consistencySelector = .readTime(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try { if case .readTime(let v)? = self.consistencySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListCollectionIdsRequest, rhs: Google_Firestore_V1_ListCollectionIdsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.consistencySelector != rhs.consistencySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListCollectionIdsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCollectionIdsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collection_ids"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.collectionIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.collectionIds, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_ListCollectionIdsResponse, rhs: Google_Firestore_V1_ListCollectionIdsResponse) -> Bool {
    if lhs.collectionIds != rhs.collectionIds {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BatchWriteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchWriteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "writes"),
    3: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.writes) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.writes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writes, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BatchWriteRequest, rhs: Google_Firestore_V1_BatchWriteRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.writes != rhs.writes {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_BatchWriteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchWriteResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "write_results"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.writeResults) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.writeResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writeResults, fieldNumber: 1)
    }
    if !self.status.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_BatchWriteResponse, rhs: Google_Firestore_V1_BatchWriteResponse) -> Bool {
    if lhs.writeResults != rhs.writeResults {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
