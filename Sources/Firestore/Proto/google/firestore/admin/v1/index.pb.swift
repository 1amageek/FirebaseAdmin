// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/firestore/admin/v1/index.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Cloud Firestore indexes enable simple and complex queries against
/// documents in a database.
public struct Google_Firestore_Admin_V1_Index {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. A server defined name for this index.
  /// The form of this name for composite indexes will be:
  /// `projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/indexes/{composite_index_id}`
  /// For single field indexes, this field will be empty.
  public var name: String = String()

  /// Indexes with a collection query scope specified allow queries
  /// against a collection that is the child of a specific document, specified at
  /// query time, and that has the same collection id.
  ///
  /// Indexes with a collection group query scope specified allow queries against
  /// all collections descended from a specific document, specified at query
  /// time, and that have the same collection id as this index.
  public var queryScope: Google_Firestore_Admin_V1_Index.QueryScope = .unspecified

  /// The fields supported by this index.
  ///
  /// For composite indexes, this is always 2 or more fields.
  /// The last field entry is always for the field path `__name__`. If, on
  /// creation, `__name__` was not specified as the last field, it will be added
  /// automatically with the same direction as that of the last field defined. If
  /// the final field in a composite index is not directional, the `__name__`
  /// will be ordered ASCENDING (unless explicitly specified).
  ///
  /// For single field indexes, this will always be exactly one entry with a
  /// field path equal to the field path of the associated field.
  public var fields: [Google_Firestore_Admin_V1_Index.IndexField] = []

  /// Output only. The serving state of the index.
  public var state: Google_Firestore_Admin_V1_Index.State = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Query Scope defines the scope at which a query is run. This is specified on
  /// a StructuredQuery's `from` field.
  public enum QueryScope: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The query scope is unspecified. Not a valid option.
    case unspecified // = 0

    /// Indexes with a collection query scope specified allow queries
    /// against a collection that is the child of a specific document, specified
    /// at query time, and that has the collection id specified by the index.
    case collection // = 1

    /// Indexes with a collection group query scope specified allow queries
    /// against all collections that has the collection id specified by the
    /// index.
    case collectionGroup // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .collection
      case 2: self = .collectionGroup
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .collection: return 1
      case .collectionGroup: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The state of an index. During index creation, an index will be in the
  /// `CREATING` state. If the index is created successfully, it will transition
  /// to the `READY` state. If the index creation encounters a problem, the index
  /// will transition to the `NEEDS_REPAIR` state.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state is unspecified.
    case unspecified // = 0

    /// The index is being created.
    /// There is an active long-running operation for the index.
    /// The index is updated when writing a document.
    /// Some index data may exist.
    case creating // = 1

    /// The index is ready to be used.
    /// The index is updated when writing a document.
    /// The index is fully populated from all stored documents it applies to.
    case ready // = 2

    /// The index was being created, but something went wrong.
    /// There is no active long-running operation for the index,
    /// and the most recently finished long-running operation failed.
    /// The index is not updated when writing a document.
    /// Some index data may exist.
    /// Use the google.longrunning.Operations API to determine why the operation
    /// that last attempted to create this index failed, then re-create the
    /// index.
    case needsRepair // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creating
      case 2: self = .ready
      case 3: self = .needsRepair
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creating: return 1
      case .ready: return 2
      case .needsRepair: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A field in an index.
  /// The field_path describes which field is indexed, the value_mode describes
  /// how the field value is indexed.
  public struct IndexField {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Can be __name__.
    /// For single field indexes, this must match the name of the field or may
    /// be omitted.
    public var fieldPath: String = String()

    /// How the field value is indexed.
    public var valueMode: Google_Firestore_Admin_V1_Index.IndexField.OneOf_ValueMode? = nil

    /// Indicates that this field supports ordering by the specified order or
    /// comparing using =, !=, <, <=, >, >=.
    public var order: Google_Firestore_Admin_V1_Index.IndexField.Order {
      get {
        if case .order(let v)? = valueMode {return v}
        return .unspecified
      }
      set {valueMode = .order(newValue)}
    }

    /// Indicates that this field supports operations on `array_value`s.
    public var arrayConfig: Google_Firestore_Admin_V1_Index.IndexField.ArrayConfig {
      get {
        if case .arrayConfig(let v)? = valueMode {return v}
        return .unspecified
      }
      set {valueMode = .arrayConfig(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// How the field value is indexed.
    public enum OneOf_ValueMode: Equatable {
      /// Indicates that this field supports ordering by the specified order or
      /// comparing using =, !=, <, <=, >, >=.
      case order(Google_Firestore_Admin_V1_Index.IndexField.Order)
      /// Indicates that this field supports operations on `array_value`s.
      case arrayConfig(Google_Firestore_Admin_V1_Index.IndexField.ArrayConfig)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_Admin_V1_Index.IndexField.OneOf_ValueMode, rhs: Google_Firestore_Admin_V1_Index.IndexField.OneOf_ValueMode) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.order, .order): return {
          guard case .order(let l) = lhs, case .order(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.arrayConfig, .arrayConfig): return {
          guard case .arrayConfig(let l) = lhs, case .arrayConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// The supported orderings.
    public enum Order: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The ordering is unspecified. Not a valid option.
      case unspecified // = 0

      /// The field is ordered by ascending field value.
      case ascending // = 1

      /// The field is ordered by descending field value.
      case descending // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .ascending
        case 2: self = .descending
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .ascending: return 1
        case .descending: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// The supported array value configurations.
    public enum ArrayConfig: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The index does not support additional array queries.
      case unspecified // = 0

      /// The index supports array containment queries.
      case contains // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .contains
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .contains: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Firestore_Admin_V1_Index.QueryScope: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_Admin_V1_Index.QueryScope] = [
    .unspecified,
    .collection,
    .collectionGroup,
  ]
}

extension Google_Firestore_Admin_V1_Index.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_Admin_V1_Index.State] = [
    .unspecified,
    .creating,
    .ready,
    .needsRepair,
  ]
}

extension Google_Firestore_Admin_V1_Index.IndexField.Order: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_Admin_V1_Index.IndexField.Order] = [
    .unspecified,
    .ascending,
    .descending,
  ]
}

extension Google_Firestore_Admin_V1_Index.IndexField.ArrayConfig: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Firestore_Admin_V1_Index.IndexField.ArrayConfig] = [
    .unspecified,
    .contains,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Google_Firestore_Admin_V1_Index: @unchecked Sendable {}
extension Google_Firestore_Admin_V1_Index.QueryScope: @unchecked Sendable {}
extension Google_Firestore_Admin_V1_Index.State: @unchecked Sendable {}
extension Google_Firestore_Admin_V1_Index.IndexField: @unchecked Sendable {}
extension Google_Firestore_Admin_V1_Index.IndexField.OneOf_ValueMode: @unchecked Sendable {}
extension Google_Firestore_Admin_V1_Index.IndexField.Order: @unchecked Sendable {}
extension Google_Firestore_Admin_V1_Index.IndexField.ArrayConfig: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.admin.v1"

extension Google_Firestore_Admin_V1_Index: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Index"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "query_scope"),
    3: .same(proto: "fields"),
    4: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.queryScope) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.queryScope != .unspecified {
      try visitor.visitSingularEnumField(value: self.queryScope, fieldNumber: 2)
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 3)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1_Index, rhs: Google_Firestore_Admin_V1_Index) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.queryScope != rhs.queryScope {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1_Index.QueryScope: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "QUERY_SCOPE_UNSPECIFIED"),
    1: .same(proto: "COLLECTION"),
    2: .same(proto: "COLLECTION_GROUP"),
  ]
}

extension Google_Firestore_Admin_V1_Index.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "READY"),
    3: .same(proto: "NEEDS_REPAIR"),
  ]
}

extension Google_Firestore_Admin_V1_Index.IndexField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_Admin_V1_Index.protoMessageName + ".IndexField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_path"),
    2: .same(proto: "order"),
    3: .standard(proto: "array_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fieldPath) }()
      case 2: try {
        var v: Google_Firestore_Admin_V1_Index.IndexField.Order?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.valueMode != nil {try decoder.handleConflictingOneOf()}
          self.valueMode = .order(v)
        }
      }()
      case 3: try {
        var v: Google_Firestore_Admin_V1_Index.IndexField.ArrayConfig?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.valueMode != nil {try decoder.handleConflictingOneOf()}
          self.valueMode = .arrayConfig(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fieldPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldPath, fieldNumber: 1)
    }
    switch self.valueMode {
    case .order?: try {
      guard case .order(let v)? = self.valueMode else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .arrayConfig?: try {
      guard case .arrayConfig(let v)? = self.valueMode else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_Admin_V1_Index.IndexField, rhs: Google_Firestore_Admin_V1_Index.IndexField) -> Bool {
    if lhs.fieldPath != rhs.fieldPath {return false}
    if lhs.valueMode != rhs.valueMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_Admin_V1_Index.IndexField.Order: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ORDER_UNSPECIFIED"),
    1: .same(proto: "ASCENDING"),
    2: .same(proto: "DESCENDING"),
  ]
}

extension Google_Firestore_Admin_V1_Index.IndexField.ArrayConfig: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ARRAY_CONFIG_UNSPECIFIED"),
    1: .same(proto: "CONTAINS"),
  ]
}
